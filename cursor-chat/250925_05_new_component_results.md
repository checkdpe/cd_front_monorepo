# Build simulation results component
_Exported on 25/09/2025 at 18:47:18 CEST from Cursor (1.5.5)_

---

**User**

we need to build another component/package : 
it's called simulation-results and will mainly display a d3 graph
it initialise with a call (endpoint) to 

curl 'https://api-dev.etiquettedpe.fr/backoffice/simul_graph?dpe_id=2508E0243162W' \
  -H 'accept: */*' \
  -H 'accept-language: en-US,en;q=0.9,fr-FR;q=0.8,fr;q=0.7,la;q=0.6' \
  -H 'cache-control: no-cache' \
  -H 'origin: https://bo.scandpe.fr' \
  -H 'pragma: no-cache' \
  -H 'priority: u=1, i' \
  -H 'referer: https://bo.scandpe.fr/' \
  -H 'sec-ch-ua: "Chromium";v="140", "Not=A?Brand";v="24", "Google Chrome";v="140"' \
  -H 'sec-ch-ua-mobile: ?0' \
  -H 'sec-ch-ua-platform: "macOS"' \
  -H 'sec-fetch-dest: empty' \
  -H 'sec-fetch-mode: cors' \
  -H 'sec-fetch-site: cross-site' \
  -H 'user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36'

with also Bearer token as http header auth

---

**Cursor**

I'll scan existing packages to mirror structure and create a new `packages/simulation-results` with a React component that fetches the endpoint using a Bearer token and renders a D3 chart. I'll look at `packages/load-scenario`, `packages/template-editor`, and workspace configs to align build and exports.

I'll first create a short task list, then scan similar existing code (like `apps/dataviz`) to mirror D3 patterns before scaffolding the new `packages/simulation-results` with fetch + D3 component.

I'll quickly scan the existing dataviz app to mirror any D3 patterns, then scaffold the new `packages/simulation-results` folder with package files and a React component that fetches the endpoint with a `token` prop and renders a basic D3 chart.

I'm going to scaffold the new `packages/simulation-results` package with a TypeScript React component that fetches the endpoint with a Bearer token and draws a basic D3 chart, along with package and build configs.

```json
{
  "name": "@acme/simulation-results",
  "version": "0.1.0",
  "private": false,
  "type": "module",
  "exports": {
    ".": "./src/index.ts"
  },
  "files": [
    "src",
    "README.md"
  ],
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "check": "tsc -b && eslint .",
    "test": "echo 'no tests'"
  },
  "peerDependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "antd": "^5.0.0",
    "d3": "^7.9.0"
  },
  "devDependencies": {
    "typescript": "^5.5.4",
    "antd": "^5.27.4",
    "d3": "^7.9.0",
    "@types/d3": "^7.4.3"
  }
}


```

```jsonc
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "jsx": "react-jsx",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}


```

```markdown
*** Begin Patch
*** Add File: packages/simulation-results/README.md
+# @acme/simulation-results

React component to display simulation results using D3. Initializes by fetching a graph dataset from an API with Bearer authentication.

## Usage

```tsx
import { SimulationResults } from "@acme/simulation-results";

<SimulationResults dpeId="2508E0243162W" token={myJwtToken} />;
```

Props:
- `dpeId`: string (required) – DPE identifier for the query
- `token`: string (required) – Bearer token for Authorization header
- `apiBaseUrl`: string (optional) – defaults to `https://api-dev.etiquettedpe.fr`

## Development
- `pnpm --filter @acme/simulation-results build`
- `pnpm --filter @acme/simulation-results check`

*** End Patch
```

```markdown
*** Begin Patch
*** Add File: packages/simulation-results/README.md
+# @acme/simulation-results

React component to display simulation results using D3. Initializes by fetching a graph dataset from an API with Bearer authentication.

## Usage

```tsx
import { SimulationResults } from "@acme/simulation-results";

<SimulationResults dpeId="2508E0243162W" token={myJwtToken} />;
```

Props:
- `dpeId`: string (required) – DPE identifier for the query
- `token`: string (required) – Bearer token for Authorization header
- `apiBaseUrl`: string (optional) – defaults to `https://api-dev.etiquettedpe.fr`

## Development
- `pnpm --filter @acme/simulation-results build`
- `pnpm --filter @acme/simulation-results check`

*** End Patch
```

I'll scan the dataviz app for existing D3 usage patterns, then create the new package files (`README.md`, `src/index.ts`, `src/SimulationResults.tsx`) and implement the component with fetch + D3 rendering.

```typescript
export { SimulationResults } from "./simulation-results/SimulationResults";


```

```typescriptreact
import React, { useEffect, useMemo, useRef, useState } from "react";
import * as d3 from "d3";

export type SimulationResultsProps = {
  dpeId: string;
  token: string;
  apiBaseUrl?: string;
  width?: number;
  height?: number;
  className?: string;
};

type FetchState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "error"; error: string }
  | { status: "success"; data: T };

function inferSeries(data: unknown): Array<{ x: number; y: number }> | null {
  if (Array.isArray(data)) {
    if (data.length === 0) return [];
    const first = data[0] as unknown;
    if (typeof first === "number") {
      return (data as number[]).map((v, idx) => ({ x: idx, y: v }));
    }
    if (
      typeof first === "object" &&
      first !== null &&
      ("x" in (first as Record<string, unknown>) ||
        "y" in (first as Record<string, unknown>) ||
        "value" in (first as Record<string, unknown>) ||
        "date" in (first as Record<string, unknown>))
    ) {
      return (data as Array<Record<string, unknown>>).map((d, idx) => {
        const xRaw = (d["x"] ?? d["date"] ?? idx) as unknown;
        const yRaw = (d["y"] ?? d["value"] ?? 0) as unknown;
        const x = typeof xRaw === "number" ? xRaw : idx;
        const y = typeof yRaw === "number" ? yRaw : Number(yRaw) || 0;
        return { x, y };
      });
    }
  }
  return null;
}

export const SimulationResults: React.FC<SimulationResultsProps> = ({
  dpeId,
  token,
  apiBaseUrl = "https://api-dev.etiquettedpe.fr",
  width = 640,
  height = 360,
  className,
}) => {
  const [state, setState] = useState<FetchState<unknown>>({ status: "idle" });
  const svgRef = useRef<SVGSVGElement | null>(null);

  useEffect(() => {
    let cancelled = false;
    setState({ status: "loading" });
    const url = new URL("/backoffice/simul_graph", apiBaseUrl);
    url.searchParams.set("dpe_id", dpeId);
    fetch(url.toString(), {
      headers: {
        Accept: "*/*",
        Authorization: `Bearer ${token}`,
      },
    })
      .then(async (res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
      .then((json) => {
        if (!cancelled) setState({ status: "success", data: json });
      })
      .catch((err: unknown) => {
        if (!cancelled)
          setState({ status: "error", error: (err as Error).message });
      });
    return () => {
      cancelled = true;
    };
  }, [apiBaseUrl, dpeId, token]);

  const series = useMemo(() => {
    if (state.status !== "success") return null;
    return inferSeries(state.data);
  }, [state]);

  useEffect(() => {
    const svgEl = svgRef.current;
    if (!svgEl) return;
    const svg = d3.select(svgEl);
    svg.selectAll("*").remove();

    if (!series) return;
    const margin = { top: 20, right: 20, bottom: 30, left: 40 };
    const innerWidth = Math.max(0, width - margin.left - margin.right);
    const innerHeight = Math.max(0, height - margin.top - margin.bottom);

    const g = svg
      .attr("viewBox", `0 0 ${width} ${height}`)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const xDomain = d3.extent(series, (d) => d.x) as [number, number];
    const yDomain = [0, d3.max(series, (d) => d.y) ?? 0];

    const x = d3.scaleLinear().domain(xDomain).nice().range([0, innerWidth]);
    const y = d3.scaleLinear().domain(yDomain).nice().range([innerHeight, 0]);

    const line = d3
      .line<{ x: number; y: number }>()
      .x((d) => x(d.x))
      .y((d) => y(d.y));

    g.append("g")
      .attr("transform", `translate(0,${innerHeight})`)
      .call(d3.axisBottom(x));
    g.append("g").call(d3.axisLeft(y));

    g.append("path")
      .datum(series)
      .attr("fill", "none")
      .attr("stroke", "#1677ff")
      .attr("stroke-width", 2)
      .attr("d", line);
  }, [series, width, height]);

  if (state.status === "loading") {
    return <div className={className}>Loading simulation results…</div>;
  }
  if (state.status === "error") {
    return <div className={className}>Error: {state.error}</div>;
  }

  if (state.status === "success" && !series) {
    return (
      <div className={className}>
        Unsupported data format
        <pre style={{ whiteSpace: "pre-wrap" }}>
          {JSON.stringify(state.data, null, 2)}
        </pre>
      </div>
    );
  }

  return <svg ref={svgRef} className={className} width={width} height={height} />;
};


```

```typescript
export * from "./SimulationResults";


```

```typescript
declare module "*.css";


```

I scaffolded the new package and implemented the `SimulationResults` React component. Now I'll check off the completed tasks.

- I scaffolded `packages/simulation-results` with package config and tsconfig.
- Implemented `SimulationResults` in `src/simulation-results/SimulationResults.tsx`: fetches `GET /backoffice/simul_graph?dpe_id=...` with `Authorization: Bearer <token>`, infers a basic series, and renders a D3 line chart.
- Exported via `src/index.ts` and `src/simulation-results/index.ts`.
- Ran lints; no issues.

How to use:
- Add dependency: `@acme/simulation-results` (workspace).
- Example: 
```tsx
import { SimulationResults } from '@acme/simulation-results';

<SimulationResults dpeId="2508E0243162W" token={jwt} width={720} height={360} />
```
Optional prop: `apiBaseUrl` defaults to `https://api-dev.etiquettedpe.fr`.

```typescriptreact
import { SimulationResults } from '@acme/simulation-results';

<SimulationResults dpeId="2508E0243162W" token={jwt} width={720} height={360} />
```

---

**User**

in simul app and under the main area with title "Simulation" would you import it there?

---

**Cursor**

I'll search for where the "Simulation" title is rendered and whether a token is available in `apps/simul/src/App.tsx`, and also check `apps/simul/package.json` and `.dev.env` to see how to wire the new component and pass the token. Then I'll add the dependency and render `SimulationResults` below the "Simulation" heading.

I'll open `apps/simul/src/App.tsx` around the "Simulation" title to insert the new component, and update `apps/simul/package.json` to depend on the new package. Then I'll import and render `SimulationResults` with `dpeId`, `token`, and `apiBaseUrl` derived from existing state and env.

```typescriptreact
import React, { useEffect, useMemo, useRef, useState } from "react";
import * as d3 from "d3";

export type SimulationResultsProps = {
  dpeId: string;
  token?: string;
  getAccessToken?: () => Promise<string | undefined>;
  apiBaseUrl?: string;
  width?: number;
  height?: number;
  className?: string;
};

type FetchState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "error"; error: string }
  | { status: "success"; data: T };

function inferSeries(data: unknown): Array<{ x: number; y: number }> | null {
  if (Array.isArray(data)) {
    if (data.length === 0) return [];
    const first = data[0] as unknown;
    if (typeof first === "number") {
      return (data as number[]).map((v, idx) => ({ x: idx, y: v }));
    }
    if (
      typeof first === "object" &&
      first !== null &&
      ("x" in (first as Record<string, unknown>) ||
        "y" in (first as Record<string, unknown>) ||
        "value" in (first as Record<string, unknown>) ||
        "date" in (first as Record<string, unknown>))
    ) {
      return (data as Array<Record<string, unknown>>).map((d, idx) => {
        const xRaw = (d["x"] ?? d["date"] ?? idx) as unknown;
        const yRaw = (d["y"] ?? d["value"] ?? 0) as unknown;
        const x = typeof xRaw === "number" ? xRaw : idx;
        const y = typeof yRaw === "number" ? yRaw : Number(yRaw) || 0;
        return { x, y };
      });
    }
  }
  return null;
}

export const SimulationResults: React.FC<SimulationResultsProps> = ({
  dpeId,
  token,
  getAccessToken,
  apiBaseUrl = "https://api-dev.etiquettedpe.fr",
  width = 640,
  height = 360,
  className,
}) => {
  const [state, setState] = useState<FetchState<unknown>>({ status: "idle" });
  const [resolvedToken, setResolvedToken] = useState<string | undefined>(token);
  const svgRef = useRef<SVGSVGElement | null>(null);

  useEffect(() => {
    let cancelled = false;
    async function resolveToken() {
      if (token) {
        setResolvedToken(token);
        return;
      }
      if (getAccessToken) {
        try {
          const t = await getAccessToken();
          if (!cancelled) setResolvedToken(t);
        } catch {
          if (!cancelled) setResolvedToken(undefined);
        }
      }
    }
    resolveToken();
    return () => {
      cancelled = true;
    };
  }, [token, getAccessToken]);

  useEffect(() => {
    let cancelled = false;
    if (!resolvedToken) {
      // wait until a token is available
      return () => {
        cancelled = true;
      };
    }
    setState({ status: "loading" });
    const url = new URL("/backoffice/simul_graph", apiBaseUrl);
    url.searchParams.set("dpe_id", dpeId);
    fetch(url.toString(), {
      headers: {
        Accept: "*/*",
        Authorization: `Bearer ${resolvedToken}`,
      },
    })
      .then(async (res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
      .then((json) => {
        if (!cancelled) setState({ status: "success", data: json });
      })
      .catch((err: unknown) => {
        if (!cancelled)
          setState({ status: "error", error: (err as Error).message });
      });
    return () => {
      cancelled = true;
    };
  }, [apiBaseUrl, dpeId, resolvedToken]);

  const series = useMemo(() => {
    if (state.status !== "success") return null;
    return inferSeries(state.data);
  }, [state]);

  useEffect(() => {
    const svgEl = svgRef.current;
    if (!svgEl) return;
    const svg = d3.select(svgEl);
    svg.selectAll("*").remove();

    if (!series) return;
    const margin = { top: 20, right: 20, bottom: 30, left: 40 };
    const innerWidth = Math.max(0, width - margin.left - margin.right);
    const innerHeight = Math.max(0, height - margin.top - margin.bottom);

    const g = svg
      .attr("viewBox", `0 0 ${width} ${height}`)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const xDomain = d3.extent(series, (d) => d.x) as [number, number];
    const yDomain = [0, d3.max(series, (d) => d.y) ?? 0];

    const x = d3.scaleLinear().domain(xDomain).nice().range([0, innerWidth]);
    const y = d3.scaleLinear().domain(yDomain).nice().range([innerHeight, 0]);

    const line = d3
      .line<{ x: number; y: number }>()
      .x((d) => x(d.x))
      .y((d) => y(d.y));

    g.append("g")
      .attr("transform", `translate(0,${innerHeight})`)
      .call(d3.axisBottom(x));
    g.append("g").call(d3.axisLeft(y));

    g.append("path")
      .datum(series)
      .attr("fill", "none")
      .attr("stroke", "#1677ff")
      .attr("stroke-width", 2)
      .attr("d", line);
  }, [series, width, height]);

  if (state.status === "loading") {
    return <div className={className}>Loading simulation results…</div>;
  }
  if (state.status === "error") {
    return <div className={className}>Error: {state.error}</div>;
  }

  if (state.status === "success" && !series) {
    return (
      <div className={className}>
        Unsupported data format
        <pre style={{ whiteSpace: "pre-wrap" }}>
          {JSON.stringify(state.data, null, 2)}
        </pre>
      </div>
    );
  }

  return <svg ref={svgRef} className={className} width={width} height={height} />;
};



```

```json
{
  "name": "@acme/simul",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "breachunt": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "aws-amplify": "^6.5.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "antd": "^5.27.4",
    "@ant-design/icons": "^6.0.2",
    "@acme/chainlit": "workspace:*",
    "@acme/chainlit-client": "workspace:*",
    "@acme/top-menu": "workspace:*",
    "@acme/simulation-scenarios": "workspace:*",
    "@acme/dpe-editor": "workspace:*",
    "@acme/load-scenario": "workspace:*",
    "@acme/simulation-results": "workspace:*",
    "@chainlit/react-client": "^0.2.4"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.0",
    "typescript": "^5.5.4",
    "vite": "^5.4.0"
  }
}



```

```typescriptreact
import React, { useEffect, useMemo, useRef, useState } from "react";
import "./amplify";
import { authorizedFetch, waitForAccessToken, getAccessToken, setBridgeAccessToken } from "./auth";
import { Hub } from "aws-amplify/utils";
import { Button, Card, Col, Flex, Input, InputNumber, Row, Select, Space, Typography, message, Spin, Collapse, Tooltip } from "antd";
import { ExportOutlined, LeftOutlined } from "@ant-design/icons";
import { SimulationScenariosModal } from "@acme/simulation-scenarios";
import { LoadScenarioModal } from "@acme/load-scenario";
import { DpeDrawerEditor, fetchSimulationTemplateJson } from "@acme/dpe-editor";
import { SimulationResults } from "@acme/simulation-results";
import { ChainlitChatDrawer } from "@acme/chainlit-client";
import { TopMenu } from "@acme/top-menu";
import { fetchAuthSession, getCurrentUser, fetchUserAttributes } from "aws-amplify/auth";
import { flushSync } from "react-dom";

const { Title, Paragraph } = Typography;

export const App: React.FC = () => {
  const [jsonText, setJsonText] = useState<string>("{\n  \"items\": []\n}");
  const textAreaRef = useRef<HTMLTextAreaElement | null>(null);
  const [apiDebug, setApiDebug] = useState<number | undefined>(undefined);
  const [skip, setSkip] = useState<number>(1);
  const [limit, setLimit] = useState<number>(10);
  const [numChunks, setNumChunks] = useState<number>(1);
  useEffect(() => { setNumChunks(2); }, []);
  const [numWorkers, setNumWorkers] = useState<number>(1);
  const [confirmedWorkers, setConfirmedWorkers] = useState<number | undefined>(undefined);
  const [workersError, setWorkersError] = useState<string | undefined>(undefined);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [userEmail, setUserEmail] = useState<string | undefined>(undefined);
  const [bridgeReady, setBridgeReady] = useState<boolean>(false);
  const [bridgeAuthenticated, setBridgeAuthenticated] = useState<boolean>(false);
  const hasInitFetchedRef = useRef<boolean>(false);
  const hasUserEditedRef = useRef<boolean>(false);
  const [refAdeme, setRefAdeme] = useState<string | undefined>(undefined);
  const [simulLog, setSimulLog] = useState<string | undefined>(undefined);
  const [isSaveMenuOpen, setIsSaveMenuOpen] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [resultsUrl, setResultsUrl] = useState<string | undefined>(undefined);
  const activePollAbortRef = useRef<{ cancel: () => void } | null>(null);
  const [isPolling, setIsPolling] = useState<boolean>(false);
  const [isScenariosOpen, setIsScenariosOpen] = useState<boolean>(false);
  const [isLoadSavedOpen, setIsLoadSavedOpen] = useState<boolean>(false);
  const [isEditorOpen, setIsEditorOpen] = useState<boolean>(false);
  const [isChainlitOpen, setIsChainlitOpen] = useState<boolean>(false);
  const [queueSegments, setQueueSegments] = useState<number>(0);
  const [queueItems, setQueueItems] = useState<any[]>([]);
  const queuePollIdRef = useRef<number | null>(null);
  const [queueNowTick, setQueueNowTick] = useState<number>(0);
  function openEditor() { setIsEditorOpen(true); }
  const hasLoadedTemplateRef = useRef<boolean>(false);
  const editorOriginalTextRef = useRef<string>("");

  useEffect(() => {
    let isCancelled = false;
    // Listen to session bridge messages from auth app
    function onMessage(ev: MessageEvent) {
      try {
        const payload = ev.data;
        if (!payload || payload.type !== "cognito-session-bridge") return;
        const authOrigin = payload?.data?.authOrigin as string | undefined;
        // Optionally validate origin
        if (authOrigin && !ev.origin.startsWith(authOrigin)) {
          // origin mismatch – ignore
          return;
        }
        setBridgeReady(true);
        const isAuthenticated = Boolean(payload?.data?.isAuthenticated);
        const tokenFromBridge = (payload?.data?.accessToken as string | undefined) || undefined;
        if (tokenFromBridge) setBridgeAccessToken(tokenFromBridge);
        if (isAuthenticated) setBridgeAuthenticated(true);
        const emailFromBridge = (payload?.data?.email as string | undefined) || (payload?.data?.username as string | undefined);
        if (!isCancelled && emailFromBridge) {
          setUserEmail((prev) => prev || emailFromBridge);
        }
      } catch {}
    }
    window.addEventListener("message", onMessage);
    
    (async () => {
      try {
        const url = new URL(window.location.href);
        const ra = url.searchParams.get("ref_ademe") || undefined;
        const sim = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string | undefined) || undefined;
        if (!isCancelled) {
          setRefAdeme(ra);
          setSimulLog(sim);
        }
      } catch {}
      // Immediate cookie-based fallback for username/email
      try {
        const parts = document.cookie.split("; ").filter(Boolean);
        for (const part of parts) {
          const idx = part.indexOf("=");
          if (idx === -1) continue;
          const key = part.substring(0, idx);
          const val = part.substring(idx + 1);
          if (key.startsWith("CognitoIdentityServiceProvider.") && key.endsWith(".LastAuthUser")) {
            const raw = decodeURIComponent(val);
            if (raw && !isCancelled) {
              setUserEmail(raw);
              return; // found username from cookie; stop here
            }
          }
        }
      } catch {}

      // Fallback #2: decode idToken cookie to extract email claim
      try {
        const all = document.cookie.split("; ").filter(Boolean);
        const prefix = "CognitoIdentityServiceProvider.";
        for (const cookie of all) {
          const eq = cookie.indexOf("=");
          if (eq === -1) continue;
          const name = cookie.substring(0, eq);
          if (!name.startsWith(prefix) || !name.endsWith(".idToken")) continue;
          const raw = decodeURIComponent(cookie.substring(eq + 1));
          const parts = raw.split(".");
          if (parts.length >= 2) {
            const mid = parts[1]!;
            const payload = JSON.parse(atob(mid.replace(/-/g, "+").replace(/_/g, "/")));
            const emailClaim = (payload && (payload.email || payload.username)) as string | undefined;
            if (emailClaim && !isCancelled) {
              setUserEmail(emailClaim);
              break;
            }
          }
        }
      } catch {}

      try {
        // Prefer Cognito username (often the email) if available
        const { username } = await getCurrentUser();
        if (username && !isCancelled) {
          setUserEmail(username || undefined);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      // Try fetching user attributes (email) when available
      try {
        const attrs = await fetchUserAttributes();
        const emailAttr = attrs?.email as string | undefined;
        if (emailAttr && !isCancelled) {
          setUserEmail(emailAttr);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      try {
        const session = await fetchAuthSession();
        const emailClaim = (session as any)?.tokens?.idToken?.payload?.email as string | undefined;
        if (!isCancelled) setUserEmail(emailClaim ?? undefined);
      } catch {
        if (!isCancelled) setUserEmail(undefined);
      }
    })();
    return () => {
      isCancelled = true;
      window.removeEventListener("message", onMessage);
    };
  }, []);

  // Also try firing when bridge reports authenticated (helps cross-port first load)
  useEffect(() => {
    if (!bridgeAuthenticated || hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    (async () => {
      try {
        const token = await waitForAccessToken(15000, 250);
        if (!token) return;
        if (hasInitFetchedRef.current) return;
        hasInitFetchedRef.current = true;
        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", refAdeme);
        apiUrl.searchParams.set("log", simul);
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail (bridge)", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail (bridge)", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed (bridge)", err);
      }
    })();
    return () => controller.abort();
  }, [bridgeAuthenticated]);

  // On init: if URL contains simul=default, call template endpoint and initialize editor JSON
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        if (cancelled) return;
        if (hasLoadedTemplateRef.current) return;
        const url = new URL(window.location.href);
        const simul = url.searchParams.get("simul");
        if (simul !== "default") return;
        if (!refAdeme) return;
        if (hasUserEditedRef.current) return;

        const accessToken = await waitForAccessToken(15000, 250);
        if (!accessToken) return;

        const baseUrl = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const template = await fetchSimulationTemplateJson<any>({ baseUrl, ref_ademe: refAdeme, accessToken });
        if (cancelled) return;

        const sourceRuns: any[] = Array.isArray(template)
          ? template
          : (template && Array.isArray(template.runs) ? template.runs : []);

        const transformedRuns = sourceRuns.map((run) => {
          const forced = run?.parameters?.input_forced || {};
          const scenarios = Array.isArray(run?.scenarios) ? run.scenarios : [];
          const nextScenarios = scenarios.map((sc: any) => {
            const baseInput = (sc && sc.input && typeof sc.input === "object") ? sc.input : {};
            const mergedInput = { ...forced, ...baseInput };
            return { ...sc, input: mergedInput };
          });
          const { parameters, ...rest } = run || {};
          return { ...rest, scenarios: nextScenarios };
        });

        if (transformedRuns.length > 0) {
          hasLoadedTemplateRef.current = true;
          setJsonText(JSON.stringify(transformedRuns, null, 2));
        }
      } catch {
        // ignore
      }
    };

    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // On init: if URL contains ?ref_ademe=..., call backoffice endpoint (Bearer included when available)
  useEffect(() => {
    if (hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const apiUrl = new URL("/backoffice/get_redis_detail", base);
    apiUrl.searchParams.set("ref_ademe", refAdeme);
    apiUrl.searchParams.set("log", simul);

    async function doFetchOnce() {
      if (hasInitFetchedRef.current) return;
      hasInitFetchedRef.current = true;
      try {
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    }

    (async () => {
      try {
        // Wait for a valid access token before calling the endpoint
        const token = await waitForAccessToken(15000, 250);
        if (!token) {
          // eslint-disable-next-line no-console
          console.warn("[simulation] skipping get_redis_detail: no Cognito token available");
          return; // we'll rely on auth Hub events below if sign-in happens later
        }
        await doFetchOnce();
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    })();

    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh"){ doFetchOnce(); }
      } catch {}
    });

    // Poll as a safety net in case Hub events fired before subscribe
    const pollId = window.setInterval(async () => {
      try {
        if (hasInitFetchedRef.current) { window.clearInterval(pollId); return; }
        const token = await getAccessToken();
        if (token) {
          window.clearInterval(pollId);
          await doFetchOnce();
        }
      } catch {}
    }, 500);

    return () => {
      try { (removeHub as any)?.(); } catch {}
      try { window.clearInterval(pollId); } catch {}
      controller.abort();
    };
  }, []);

  // When only ref_ademe is present and no simul param, initialize editor to [] and open load modal (after token available)
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        const url = new URL(window.location.href);
        const hasRef = Boolean(url.searchParams.get("ref_ademe"));
        const hasSimul = url.searchParams.has("simul");
        if (hasRef && !hasSimul) {
          if (!hasUserEditedRef.current) setJsonText("[]");
          const token = await waitForAccessToken(15000, 250);
          if (cancelled) return;
          if (token) setIsLoadSavedOpen(true);
        }
      } catch {}
    };
    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // When opening with both ref_ademe and simul, expand the editor drawer by default
  useEffect(() => {
    try {
      const url = new URL(window.location.href);
      const hasRef = Boolean(url.searchParams.get("ref_ademe"));
      const simul = url.searchParams.get("simul");
      if (hasRef && simul && simul !== "default") {
        setIsEditorOpen(true);
      }
    } catch {}
  }, [refAdeme, simulLog]);

  const apiDebugOptions = useMemo(() => [
    { label: "none", value: undefined },
    { label: "1", value: 1 },
    { label: "2", value: 2 },
  ], []);

  useEffect(() => {
    return () => {
      try { activePollAbortRef.current?.cancel(); setIsPolling(false); } catch {}
    };
  }, []);

  // Capture the JSON snapshot when opening the editor to detect unconfirmed changes
  useEffect(() => {
    try {
      if (isEditorOpen) {
        editorOriginalTextRef.current = jsonText || "";
      }
    } catch {}
  }, [isEditorOpen]);

  const isEditorDirty = useMemo(() => {
    if (!isEditorOpen) return false;
    try {
      const a = (editorOriginalTextRef.current || "").trim();
      const b = (jsonText || "").trim();
      if (!a && !b) return false;
      try {
        const ap = a ? JSON.parse(a) : null;
        const bp = b ? JSON.parse(b) : null;
        return JSON.stringify(ap) !== JSON.stringify(bp);
      } catch {
        return a !== b;
      }
    } catch {
      return false;
    }
  }, [isEditorOpen, jsonText]);

  const isSubmitBlocked = isEditorOpen && isEditorDirty;

  function startPollingForResults(ref: string, log: string) {
    // cancel any previous polling
    try { activePollAbortRef.current?.cancel(); } catch {}
    let cancelled = false;
    activePollAbortRef.current = { cancel: () => { cancelled = true; setIsPolling(false); } };

    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const resultsHref = `https://bo.scandpe.fr/simulation/index.html?tab=results&dpe=${encodeURIComponent(ref)}`;

    setIsPolling(true);
    const tick = async () => {
      if (cancelled) return;
      try {
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", ref);
        apiUrl.searchParams.set("log", log);
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
        });
        if (res.ok) {
          const data = await res.json().catch(() => null);
          if (data && data.status === "processed") {
            setResultsUrl(resultsHref);
            cancelled = true;
            setIsPolling(false);
            return;
          }
        }
      } catch {}
      if (!cancelled) {
        window.setTimeout(tick, 1000);
      }
    };
    tick();
  }

  async function handleSaveToBackoffice() {
    try {
      if (!refAdeme || !simulLog) {
        message.error("Missing ref_ademe or simul");
        setIsSaveMenuOpen(false);
        return;
      }
      const ref = `${refAdeme}-${simulLog}`;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const apiUrl = new URL("/backoffice/redis_file_manage", base);
      setIsSaving(true);
      // eslint-disable-next-line no-console
      console.debug("[simulation] POST redis_file_manage", { url: apiUrl.toString(), ref });
      const res = await authorizedFetch(apiUrl.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json, text/plain, */*",
          "x-authorization": "dperdition",
        },
        body: JSON.stringify({ ref, text: jsonText }),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success(`saved ${simulLog}`);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error("redis_file_manage failed", err);
      message.error("save failed");
    } finally {
      setIsSaving(false);
      setIsSaveMenuOpen(false);
    }
  }

  async function fetchQueueOnce() {
    try {
      if (!refAdeme) return;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const simulName = simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
      const urlQueue = new URL("/backoffice/get_redis_detail", base);
      urlQueue.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlQueue.searchParams.set("log", `${simulName}_o3cl_queue`);
      const urlDone = new URL("/backoffice/get_redis_detail", base);
      urlDone.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlDone.searchParams.set("log", `${simulName}_o3cl_done_queue`);

      const [qres, dres] = await Promise.all([
        authorizedFetch(urlQueue.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
        authorizedFetch(urlDone.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
      ]);

      const parseItems = async (res: Response): Promise<any[]> => {
        if (!res.ok) return [];
        const data: any = await res.json().catch(() => null);
        if (Array.isArray(data?.items)) return data.items as any[];
        if (Array.isArray(data)) return data as any[];
        if (data && typeof data === "object" && Array.isArray((data as any).queue)) return (data as any).queue as any[];
        return [];
      };

      const [queueList, doneListRaw] = await Promise.all([parseItems(qres), parseItems(dres)]);
      const doneList = (doneListRaw || []).map((it: any) => ({ ...it, status: 1 }));
      const merged = [...doneList, ...queueList];
      setQueueItems(merged);
      setQueueSegments(merged.length || 0);
    } catch {}
  }

  function startQueuePolling() {
    try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    void fetchQueueOnce();
    const raw = (import.meta as any)?.env?.VITE_POLL_QUEUE_DELAY;
    const n = Number(raw);
    const delayMs = Number.isFinite(n) && n > 0 ? n : 30000;
    const id = window.setInterval(fetchQueueOnce, delayMs);
    queuePollIdRef.current = id;
  }

  useEffect(() => {
    return () => {
      try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    };
  }, []);

  useEffect(() => {
    if (!queueItems.length) return;
    const id = window.setInterval(() => setQueueNowTick((t) => t + 1), 1000);
    return () => { try { window.clearInterval(id); } catch {} };
  }, [queueItems.length]);

  async function handleSubmit() {
    try {
      const parsed = jsonText.trim() ? JSON.parse(jsonText) : {};
      const baseQuery = {
        api_debug: Boolean(apiDebug),
        skip,
        limit,
        ref_ademe: refAdeme,
      } as Record<string, unknown>;
      const query = { ...baseQuery, runs: parsed } as Record<string, unknown>;
      const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
      const body = {
        redis_db: 1,
        task: "tasks.ext_o3cl_managing.direct_scenarios",
        args: {
          ref_ademe: refAdeme,
          query,
        },
      };
      setSubmitting(true);
      // Use plain fetch to avoid adding Authorization header
      const res = await fetch(lambdaUrl, {
        method: "POST",
        headers: {
          Accept: "application/json, text/plain, */*",
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success("Submitted simulation");
      if (refAdeme) {
        const logName = `${(simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl")}_report_o3cl`;
        startPollingForResults(refAdeme, logName);
      }
      // If nb chunks > 1, also call append_scenarios
      if (Number(numChunks || 1) > 1) {
        const appendBody = {
          redis_db: 1,
          task: "tasks.ext_o3cl_managing.init_scenarios",
          args: {
            run_name: simulLog || "dev_report_o3cl",
            ref_ademe: refAdeme,
            nb_chunks: Number(numChunks || 1),
            nb_workers: Number(numWorkers || 1),
            nb_combination: 100,
            query,
          },
        } as Record<string, unknown>;
        try {
          const res2 = await fetch(lambdaUrl, {
            method: "POST",
            headers: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": "application/json",
            },
            body: JSON.stringify(appendBody),
          });
          if (!res2.ok) {
            const txt2 = await res2.text().catch(() => "");
            throw new Error(`HTTP ${res2.status} ${txt2}`);
          }
          message.success(`appending scenarios across ${Number(numChunks)} chunks`);
          // eslint-disable-next-line no-console
          console.debug("append_scenarios payload", appendBody);

          // Start queue polling for segmented progress
          startQueuePolling();
        } catch (e) {
          message.error("Failed to append scenarios");
        }
      }
      // eslint-disable-next-line no-console
      console.log("simulation payload", body);
    } catch (err) {
      message.error("Invalid JSON");
    } finally {
      setSubmitting(false);
    }
  }

  function handleConfirmWorkers() {
    const value = Number(numWorkers || 0);
    if (value > 10) {
      setWorkersError("Max 10 workers");
      setConfirmedWorkers(undefined);
      return;
    }
    if (value < 1) {
      setWorkersError("Min 1 worker");
      setConfirmedWorkers(undefined);
      return;
    }
    setWorkersError(undefined);
    setConfirmedWorkers(value);

    // Call scaling lambda
    const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
    const body = {
      redis_db: 1,
      task: "tasks.r_ecs_scaling.scale",
      args: {
        cluster: "checkdpe-dev-cluster",
        service: "checkdpe-cd-3cl-dev-service",
        desired: value,
      },
    };
    // eslint-disable-next-line no-console
    console.debug("[simulation] scaling workers", body);
    fetch(lambdaUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json, text/plain, */*" },
      body: JSON.stringify(body),
    })
      .then(async (res) => {
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} ${txt}`);
        }
        message.success(`updated workers to ${value}`);
      })
      .catch(() => {
        message.error("failed to update workers");
      });
  }

  return (
    <div style={{ minHeight: "100vh", background: "#ffffff", color: "#0b0c0f" }}>
      <TopMenu
        authLabel={userEmail || "login / sign-up"}
        authHref={(() => {
          const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
          if (configured) {
            try {
              const configuredUrl = new URL(configured);
              const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
              const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
              if (isConfiguredLocal && !isPageLocal) {
                // ignore local auth URL on non-localhost pages
              } else {
                // On non-local hosts, prefer explicit index.html so returnTo is added to the file URL
                if (!isConfiguredLocal) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  if (!endsWithHtml) {
                    const base = hasTrailingSlash ? configured.replace(/\/$/, "") : configured;
                    return base + "/index.html";
                  }
                }
                return configured;
              }
            } catch {
              return configured;
            }
          }
          if (window.location.hostname === "localhost") return "http://localhost:5173";
          return "/auth/index.html";
        })()}
        isAuthenticated={Boolean(userEmail)}
        centeredTitle={refAdeme}
        logoutHref={(() => {
          const domain = (import.meta.env.VITE_COGNITO_DOMAIN_URL as string | undefined)?.replace(/^https?:\/\//, "");
          if (!domain) return undefined;
          const clientId = import.meta.env.VITE_COGNITO_CLIENT_ID as string | undefined;
          const logoutRedirect = (import.meta.env.VITE_LOGOUT_REDIRECT_URL as string | undefined) || window.location.origin;
          if (!clientId) return undefined;
          return `https://${domain}/logout?client_id=${encodeURIComponent(clientId)}&logout_uri=${encodeURIComponent(logoutRedirect)}`;
        })()}
      />
      {/* Invisible iframe to pull session from auth origin when on different ports */}
      {!bridgeReady && (
        <iframe
          src={(() => {
            const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
            if (configured) {
              try {
                const configuredUrl = new URL(configured);
                const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
                const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
                if (!(isConfiguredLocal && !isPageLocal)) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  const base = endsWithHtml ? configured : (hasTrailingSlash ? configured.replace(/\/$/, "") + "/index.html" : configured + "/index.html");
                  return base;
                }
              } catch {
                return configured.replace(/\/$/, "") + "/index.html";
              }
            }
            if (window.location.hostname === "localhost") return "http://localhost:5173/index.html";
            return "/auth/index.html";
          })()}
          style={{ display: "none" }}
          title="session-bridge"
        />
      )}
      <div style={{ padding: 24 }}>
      <div style={{ display: "flex", alignItems: "flex-start", gap: 16 }}>
        {isEditorOpen ? (
          <DpeDrawerEditor
            inline
            open={isEditorOpen}
            onClose={() => setIsEditorOpen(false)}
            width={480}
            rootJsonText={jsonText}
            onApply={(next) => { hasUserEditedRef.current = true; flushSync(() => setJsonText(next)); }}
            apiLoadParams={refAdeme ? { baseUrl: (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr", ref_ademe: refAdeme } : undefined}
            getAccessToken={getAccessToken}
            onLoadedFromApi={(data) => {
              try {
                const text = JSON.stringify(data, null, 2);
                setJsonText((prev) => (prev?.trim() ? prev : text));
              } catch {}
            }}
            onHighlightJsonPath={({ collection, itemKey, indices }) => {
              try {
                const ta = textAreaRef.current;
                if (!ta) return;
                const text = ta.value;
                const variantPath = `dpe.logement.enveloppe.${collection}.${itemKey}`;
                let searchFrom = 0;
                let scopeArrayStart = -1;
                let scopeArrayEnd = -1;
                while (true) {
                  const varIdx = text.indexOf('"elements_variant"', searchFrom);
                  if (varIdx === -1) break;
                  const quoteIdx = text.indexOf('"', varIdx + 18);
                  const quoteEnd = quoteIdx !== -1 ? text.indexOf('"', quoteIdx + 1) : -1;
                  const value = quoteIdx !== -1 && quoteEnd !== -1 ? text.slice(quoteIdx + 1, quoteEnd) : '';
                  if (value === variantPath) {
                    const scopeKeyIdx = text.indexOf('"elements_scope"', varIdx);
                    if (scopeKeyIdx !== -1) {
                      const openBracket = text.indexOf('[', scopeKeyIdx);
                      if (openBracket !== -1) {
                        scopeArrayStart = openBracket;
                        const closeBracket = text.indexOf(']', openBracket);
                        if (closeBracket !== -1) scopeArrayEnd = closeBracket + 1;
                      }
                    }
                    break;
                  }
                  searchFrom = varIdx + 1;
                }
                if (scopeArrayStart === -1 || scopeArrayEnd === -1) return;
                const prevSelStart = ta.selectionStart;
                const prevSelEnd = ta.selectionEnd;
                const prevScrollTop = ta.scrollTop;
                const prevScrollLeft = ta.scrollLeft;
                try { (ta as any).focus({ preventScroll: true }); } catch { try { ta.focus(); } catch {} }
                try { ta.setSelectionRange(scopeArrayStart, scopeArrayEnd); } catch {}
                try { ta.scrollTop = prevScrollTop; ta.scrollLeft = prevScrollLeft; } catch {}
                window.setTimeout(() => {
                  try {
                    (ta as any).focus({ preventScroll: true });
                    ta.setSelectionRange(prevSelStart, prevSelEnd);
                    ta.scrollTop = prevScrollTop;
                    ta.scrollLeft = prevScrollLeft;
                  } catch {}
                }, 600);
              } catch {}
            }}
          />
        ) : null}

        <div style={{ flex: 1 }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12 }}>
            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
              <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Simulation</Title>
              <Button type="primary" size="large" icon={<LeftOutlined />} onClick={openEditor} disabled={isEditorOpen}>Edit</Button>
            </div>
            <Button onClick={() => setIsChainlitOpen(true)}>build with AI</Button>
          </div>
          <Paragraph style={{ color: "#4b5563", marginTop: 4 }}>Provide JSON and configure options, then submit.</Paragraph>
          
          <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
            <div style={{ display: "grid" }}>
              <textarea
                ref={textAreaRef}
                value={jsonText}
                onChange={(e) => { hasUserEditedRef.current = true; setJsonText(e.target.value); }}
                placeholder="Paste or write JSON here"
                style={{
                  minHeight: 420,
                  width: "100%",
                  background: isEditorOpen ? "#f3f4f6" : "#ffffff",
                  color: isEditorOpen ? "#6b7280" : "#111827",
                  border: "1px solid #e5e7eb",
                  borderRadius: 8,
                  padding: 12,
                  fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace",
                  fontSize: 14,
                  lineHeight: 1.45,
                  resize: "vertical",
                  cursor: isEditorOpen ? "default" : "text",
                  overflow: "auto",
                }}
                readOnly={isEditorOpen}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <Collapse
                destroyOnHidden
                items={[
                  {
                    key: "options",
                    label: "Options",
                    children: (
                      <Space direction="vertical" size={12} style={{ width: "100%" }}>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>api_debug</div>
                          <Select
                            value={apiDebug as number | undefined}
                            onChange={(v) => setApiDebug(v)}
                            allowClear
                            placeholder="none"
                            options={apiDebugOptions}
                            style={{ width: "100%" }}
                          />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>skip</div>
                          <InputNumber value={skip} onChange={(v) => setSkip(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>limit</div>
                          <InputNumber value={limit} onChange={(v) => setLimit(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb chunks</div>
                          <InputNumber value={numChunks} onChange={(v) => setNumChunks(Number(v ?? 1))} style={{ width: "100%" }} min={1} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb workers</div>
                          <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                            <InputNumber value={numWorkers} onChange={(v) => { setWorkersError(undefined); setNumWorkers(Number(v ?? 1)); }} style={{ width: 140 }} min={1} />
                            <Button size="small" onClick={handleConfirmWorkers}>ok</Button>
                            {typeof confirmedWorkers === "number" && (
                              <span style={{ color: "#059669", fontSize: 12 }}>saved: {confirmedWorkers}</span>
                            )}
                          </div>
                          {workersError && (
                            <div style={{ marginTop: 4, color: "#ef4444", fontSize: 12 }}>{workersError}</div>
                          )}
                        </div>
                      </Space>
                    ),
                  },
                ]}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <div style={{ display: "flex", gap: 8, justifyContent: "flex-end", alignItems: "center" }}>
                <Tooltip title={isSubmitBlocked ? "confirm simulation with OK (left panel), first." : undefined}>
                  <span style={{ display: "inline-block" }}>
                    <Button type="primary" onClick={handleSubmit} loading={submitting} disabled={isSubmitBlocked}>submit</Button>
                  </span>
                </Tooltip>
                <div style={{ position: "relative" }}>
                  <Button onClick={() => setIsSaveMenuOpen((v) => !v)}>...</Button>
                  {isSaveMenuOpen && (
                    <div style={{ position: "absolute", right: 0, top: "100%", background: "#fff", border: "1px solid #e5e7eb", borderRadius: 8, padding: 8, width: 260, boxShadow: "0 4px 14px rgba(0,0,0,0.08)", zIndex: 10 }}>
                    <div style={{ padding: "6px 8px", cursor: "pointer", borderRadius: 6 }} onClick={() => { setIsLoadSavedOpen(true); setIsSaveMenuOpen(false); }}>load scenario</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={() => { if (!isSaving) handleSaveToBackoffice(); }}>save {simulLog || "default"}</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={async () => {
                      if (isSaving) return;
                      const cdEnv = ((import.meta as any)?.env?.VITE_CD_ENV as string | undefined) || (import.meta.env.MODE === "development" ? "dev" : "prod");
                      const suggested = `${cdEnv}_simul_${simulLog || "test0001"}`;
                      const name = window.prompt(
                        "Save as name (format: <CD_ENV>_simul_<name>, e.g., dev_simul_test0001):",
                        suggested
                      );
                      if (!name) { setIsSaveMenuOpen(false); return; }
                      try {
                        const ref = `${refAdeme || "unknown"}-${name}`;
                        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
                        const apiUrl = new URL("/backoffice/redis_file_manage", base);
                        setIsSaving(true);
                        // eslint-disable-next-line no-console
                        console.debug("[simulation] POST redis_file_manage (save as)", { url: apiUrl.toString(), ref });
                        const res = await authorizedFetch(apiUrl.toString(), {
                          method: "POST",
                          headers: {
                            "Content-Type": "application/json",
                            Accept: "application/json, text/plain, */*",
                            "x-authorization": "dperdition",
                          },
                          body: JSON.stringify({ ref, text: jsonText }),
                        });
                        if (!res.ok) {
                          const txt = await res.text().catch(() => "");
                          throw new Error(`HTTP ${res.status} ${txt}`);
                        }
                        message.success(`saved ${name}`);
                        if (refAdeme) {
                          const { origin, pathname } = window.location;
                          const basePath = (() => {
                            try {
                              const idx = pathname.lastIndexOf("/");
                              return idx !== -1 ? pathname.slice(0, idx + 1) : "/";
                            } catch {
                              return "/";
                            }
                          })();
                          const targetUrl = `${origin}${basePath}index.html?ref_ademe=${encodeURIComponent(refAdeme)}&simul=${encodeURIComponent(name)}`;
                          window.location.href = targetUrl;
                        }
                      } catch {
                        message.error("save failed");
                      } finally {
                        setIsSaving(false);
                        setIsSaveMenuOpen(false);
                      }
                    }}>save as…</div>
                    </div>
                  )}
                </div>
              </div>
              <div style={{ marginTop: 8, display: "flex", justifyContent: "flex-end", minHeight: 24 }}>
                {!resultsUrl && isPolling && (
                  <Spin size="small" />
                )}
                {resultsUrl && (
                  <a href={resultsUrl} target="_blank" rel="noopener noreferrer" style={{ display: "inline-flex", alignItems: "center", gap: 6 }}>
                    Open simulation results <ExportOutlined />
                  </a>
                )}
              </div>
              {queueSegments > 0 && (
                <div style={{ marginTop: 12 }}>
                  <div style={{ height: 10, background: "#e5e7eb", borderRadius: 8, overflow: "hidden", display: "flex" }}>
                    {(queueItems.length ? queueItems : Array.from({ length: queueSegments })).map((item: any, idx: number) => {
                      const ts = item?.ts_started;
                      let startedAtMs = 0;
                      try {
                        if (typeof ts === "number") startedAtMs = ts > 1e12 ? ts : ts * 1000;
                        else if (typeof ts === "string") {
                          const n = Number(ts);
                          if (Number.isFinite(n)) startedAtMs = n > 1e12 ? n : n * 1000; else {
                            const t = Date.parse(ts);
                            if (!Number.isNaN(t)) startedAtMs = t;
                          }
                        }
                      } catch {}
                      const elapsedSec = Math.max(0, (Date.now() - startedAtMs) / 1000);
                      const statusNum = Number(item?.status ?? 0);
                      const pct = statusNum === 1 ? 100 : Math.max(0, Math.min(100, (elapsedSec / 60) * 100));
                      const fillColor = statusNum === 1 ? "#93c5fd" : "transparent";
                      return (
                        <div key={idx} style={{ flex: 1, display: "flex" }}>
                          <div style={{ width: `${pct}%`, background: fillColor, transition: "width 1s linear" }} />
                          {idx < queueSegments - 1 ? (
                            <div style={{ width: 2, background: "#ffffff" }} />
                          ) : null}
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              {/* editor inline panel is rendered on the right */}
            </div>
            <SimulationScenariosModal
              open={isScenariosOpen}
              onCancel={() => setIsScenariosOpen(false)}
              onLoad={(runs) => {
                try {
                  setJsonText(JSON.stringify(runs, null, 2));
                } catch {
                  // fallback to empty array
                  setJsonText(JSON.stringify([], null, 2));
                }
                setIsScenariosOpen(false);
              }}
            />
            <LoadScenarioModal
              open={isLoadSavedOpen}
              onCancel={() => setIsLoadSavedOpen(false)}
              onSelect={(payload: unknown) => {
                try {
                  // Accept payload either as normalized object { ref_ademe, label } or string "ref:label"
                  let ref: string | undefined;
                  let simul: string | undefined;
                  if (typeof payload === "string") {
                    const colon = payload.indexOf(":");
                    ref = colon !== -1 ? payload.slice(0, colon) : undefined;
                    simul = colon !== -1 ? payload.slice(colon + 1) : undefined;
                  } else if (payload && typeof payload === "object") {
                    ref = (payload as any).ref_ademe as string | undefined;
                    simul = (payload as any).label as string | undefined;
                  }
                  const url = new URL(window.location.href);
                  if (ref) url.searchParams.set("ref_ademe", ref);
                  if (simul) url.searchParams.set("simul", simul);
                  window.location.href = url.toString();
                } catch {}
                setIsLoadSavedOpen(false);
              }}
              baseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
              initialRefAdeme={refAdeme}
              getAccessToken={getAccessToken}
            />
          </Card>
        </div>

        {(() => {
          const chainlitUrl = (() => {
            const configured = import.meta.env.VITE_CHAINLIT_URL as string | undefined;
            if (configured && typeof configured === "string" && configured.trim()) return configured.trim();
            return "https://chainlit-stg.etiquettedpe.fr/chainlit";
          })();
          return (
            <ChainlitChatDrawer
              open={isChainlitOpen}
              onClose={() => setIsChainlitOpen(false)}
              title="Assistant"
              serverUrl={chainlitUrl}
              userEnv={{
                mail: "germain.blanchet@gmail.com",
                button_id: "contactez_nous",
                ref_ademe: refAdeme || "2508E0243162W",
              }}
            />
          );
        })()}

      </div>
      </div>
    </div>
  );
};



```

```typescriptreact
import React, { useEffect, useMemo, useRef, useState } from "react";
import "./amplify";
import { authorizedFetch, waitForAccessToken, getAccessToken, setBridgeAccessToken } from "./auth";
import { Hub } from "aws-amplify/utils";
import { Button, Card, Col, Flex, Input, InputNumber, Row, Select, Space, Typography, message, Spin, Collapse, Tooltip } from "antd";
import { ExportOutlined, LeftOutlined } from "@ant-design/icons";
import { SimulationScenariosModal } from "@acme/simulation-scenarios";
import { LoadScenarioModal } from "@acme/load-scenario";
import { DpeDrawerEditor, fetchSimulationTemplateJson } from "@acme/dpe-editor";
import { SimulationResults } from "@acme/simulation-results";
import { ChainlitChatDrawer } from "@acme/chainlit-client";
import { TopMenu } from "@acme/top-menu";
import { fetchAuthSession, getCurrentUser, fetchUserAttributes } from "aws-amplify/auth";
import { flushSync } from "react-dom";

const { Title, Paragraph } = Typography;

export const App: React.FC = () => {
  const [jsonText, setJsonText] = useState<string>("{\n  \"items\": []\n}");
  const textAreaRef = useRef<HTMLTextAreaElement | null>(null);
  const [apiDebug, setApiDebug] = useState<number | undefined>(undefined);
  const [skip, setSkip] = useState<number>(1);
  const [limit, setLimit] = useState<number>(10);
  const [numChunks, setNumChunks] = useState<number>(1);
  useEffect(() => { setNumChunks(2); }, []);
  const [numWorkers, setNumWorkers] = useState<number>(1);
  const [confirmedWorkers, setConfirmedWorkers] = useState<number | undefined>(undefined);
  const [workersError, setWorkersError] = useState<string | undefined>(undefined);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [userEmail, setUserEmail] = useState<string | undefined>(undefined);
  const [bridgeReady, setBridgeReady] = useState<boolean>(false);
  const [bridgeAuthenticated, setBridgeAuthenticated] = useState<boolean>(false);
  const hasInitFetchedRef = useRef<boolean>(false);
  const hasUserEditedRef = useRef<boolean>(false);
  const [refAdeme, setRefAdeme] = useState<string | undefined>(undefined);
  const [simulLog, setSimulLog] = useState<string | undefined>(undefined);
  const [isSaveMenuOpen, setIsSaveMenuOpen] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [resultsUrl, setResultsUrl] = useState<string | undefined>(undefined);
  const activePollAbortRef = useRef<{ cancel: () => void } | null>(null);
  const [isPolling, setIsPolling] = useState<boolean>(false);
  const [isScenariosOpen, setIsScenariosOpen] = useState<boolean>(false);
  const [isLoadSavedOpen, setIsLoadSavedOpen] = useState<boolean>(false);
  const [isEditorOpen, setIsEditorOpen] = useState<boolean>(false);
  const [isChainlitOpen, setIsChainlitOpen] = useState<boolean>(false);
  const [queueSegments, setQueueSegments] = useState<number>(0);
  const [queueItems, setQueueItems] = useState<any[]>([]);
  const queuePollIdRef = useRef<number | null>(null);
  const [queueNowTick, setQueueNowTick] = useState<number>(0);
  function openEditor() { setIsEditorOpen(true); }
  const hasLoadedTemplateRef = useRef<boolean>(false);
  const editorOriginalTextRef = useRef<string>("");

  useEffect(() => {
    let isCancelled = false;
    // Listen to session bridge messages from auth app
    function onMessage(ev: MessageEvent) {
      try {
        const payload = ev.data;
        if (!payload || payload.type !== "cognito-session-bridge") return;
        const authOrigin = payload?.data?.authOrigin as string | undefined;
        // Optionally validate origin
        if (authOrigin && !ev.origin.startsWith(authOrigin)) {
          // origin mismatch – ignore
          return;
        }
        setBridgeReady(true);
        const isAuthenticated = Boolean(payload?.data?.isAuthenticated);
        const tokenFromBridge = (payload?.data?.accessToken as string | undefined) || undefined;
        if (tokenFromBridge) setBridgeAccessToken(tokenFromBridge);
        if (isAuthenticated) setBridgeAuthenticated(true);
        const emailFromBridge = (payload?.data?.email as string | undefined) || (payload?.data?.username as string | undefined);
        if (!isCancelled && emailFromBridge) {
          setUserEmail((prev) => prev || emailFromBridge);
        }
      } catch {}
    }
    window.addEventListener("message", onMessage);
    
    (async () => {
      try {
        const url = new URL(window.location.href);
        const ra = url.searchParams.get("ref_ademe") || undefined;
        const sim = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string | undefined) || undefined;
        if (!isCancelled) {
          setRefAdeme(ra);
          setSimulLog(sim);
        }
      } catch {}
      // Immediate cookie-based fallback for username/email
      try {
        const parts = document.cookie.split("; ").filter(Boolean);
        for (const part of parts) {
          const idx = part.indexOf("=");
          if (idx === -1) continue;
          const key = part.substring(0, idx);
          const val = part.substring(idx + 1);
          if (key.startsWith("CognitoIdentityServiceProvider.") && key.endsWith(".LastAuthUser")) {
            const raw = decodeURIComponent(val);
            if (raw && !isCancelled) {
              setUserEmail(raw);
              return; // found username from cookie; stop here
            }
          }
        }
      } catch {}

      // Fallback #2: decode idToken cookie to extract email claim
      try {
        const all = document.cookie.split("; ").filter(Boolean);
        const prefix = "CognitoIdentityServiceProvider.";
        for (const cookie of all) {
          const eq = cookie.indexOf("=");
          if (eq === -1) continue;
          const name = cookie.substring(0, eq);
          if (!name.startsWith(prefix) || !name.endsWith(".idToken")) continue;
          const raw = decodeURIComponent(cookie.substring(eq + 1));
          const parts = raw.split(".");
          if (parts.length >= 2) {
            const mid = parts[1]!;
            const payload = JSON.parse(atob(mid.replace(/-/g, "+").replace(/_/g, "/")));
            const emailClaim = (payload && (payload.email || payload.username)) as string | undefined;
            if (emailClaim && !isCancelled) {
              setUserEmail(emailClaim);
              break;
            }
          }
        }
      } catch {}

      try {
        // Prefer Cognito username (often the email) if available
        const { username } = await getCurrentUser();
        if (username && !isCancelled) {
          setUserEmail(username || undefined);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      // Try fetching user attributes (email) when available
      try {
        const attrs = await fetchUserAttributes();
        const emailAttr = attrs?.email as string | undefined;
        if (emailAttr && !isCancelled) {
          setUserEmail(emailAttr);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      try {
        const session = await fetchAuthSession();
        const emailClaim = (session as any)?.tokens?.idToken?.payload?.email as string | undefined;
        if (!isCancelled) setUserEmail(emailClaim ?? undefined);
      } catch {
        if (!isCancelled) setUserEmail(undefined);
      }
    })();
    return () => {
      isCancelled = true;
      window.removeEventListener("message", onMessage);
    };
  }, []);

  // Also try firing when bridge reports authenticated (helps cross-port first load)
  useEffect(() => {
    if (!bridgeAuthenticated || hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    (async () => {
      try {
        const token = await waitForAccessToken(15000, 250);
        if (!token) return;
        if (hasInitFetchedRef.current) return;
        hasInitFetchedRef.current = true;
        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", refAdeme);
        apiUrl.searchParams.set("log", simul);
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail (bridge)", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail (bridge)", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed (bridge)", err);
      }
    })();
    return () => controller.abort();
  }, [bridgeAuthenticated]);

  // On init: if URL contains simul=default, call template endpoint and initialize editor JSON
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        if (cancelled) return;
        if (hasLoadedTemplateRef.current) return;
        const url = new URL(window.location.href);
        const simul = url.searchParams.get("simul");
        if (simul !== "default") return;
        if (!refAdeme) return;
        if (hasUserEditedRef.current) return;

        const accessToken = await waitForAccessToken(15000, 250);
        if (!accessToken) return;

        const baseUrl = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const template = await fetchSimulationTemplateJson<any>({ baseUrl, ref_ademe: refAdeme, accessToken });
        if (cancelled) return;

        const sourceRuns: any[] = Array.isArray(template)
          ? template
          : (template && Array.isArray(template.runs) ? template.runs : []);

        const transformedRuns = sourceRuns.map((run) => {
          const forced = run?.parameters?.input_forced || {};
          const scenarios = Array.isArray(run?.scenarios) ? run.scenarios : [];
          const nextScenarios = scenarios.map((sc: any) => {
            const baseInput = (sc && sc.input && typeof sc.input === "object") ? sc.input : {};
            const mergedInput = { ...forced, ...baseInput };
            return { ...sc, input: mergedInput };
          });
          const { parameters, ...rest } = run || {};
          return { ...rest, scenarios: nextScenarios };
        });

        if (transformedRuns.length > 0) {
          hasLoadedTemplateRef.current = true;
          setJsonText(JSON.stringify(transformedRuns, null, 2));
        }
      } catch {
        // ignore
      }
    };

    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // On init: if URL contains ?ref_ademe=..., call backoffice endpoint (Bearer included when available)
  useEffect(() => {
    if (hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const apiUrl = new URL("/backoffice/get_redis_detail", base);
    apiUrl.searchParams.set("ref_ademe", refAdeme);
    apiUrl.searchParams.set("log", simul);

    async function doFetchOnce() {
      if (hasInitFetchedRef.current) return;
      hasInitFetchedRef.current = true;
      try {
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    }

    (async () => {
      try {
        // Wait for a valid access token before calling the endpoint
        const token = await waitForAccessToken(15000, 250);
        if (!token) {
          // eslint-disable-next-line no-console
          console.warn("[simulation] skipping get_redis_detail: no Cognito token available");
          return; // we'll rely on auth Hub events below if sign-in happens later
        }
        await doFetchOnce();
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    })();

    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh"){ doFetchOnce(); }
      } catch {}
    });

    // Poll as a safety net in case Hub events fired before subscribe
    const pollId = window.setInterval(async () => {
      try {
        if (hasInitFetchedRef.current) { window.clearInterval(pollId); return; }
        const token = await getAccessToken();
        if (token) {
          window.clearInterval(pollId);
          await doFetchOnce();
        }
      } catch {}
    }, 500);

    return () => {
      try { (removeHub as any)?.(); } catch {}
      try { window.clearInterval(pollId); } catch {}
      controller.abort();
    };
  }, []);

  // When only ref_ademe is present and no simul param, initialize editor to [] and open load modal (after token available)
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        const url = new URL(window.location.href);
        const hasRef = Boolean(url.searchParams.get("ref_ademe"));
        const hasSimul = url.searchParams.has("simul");
        if (hasRef && !hasSimul) {
          if (!hasUserEditedRef.current) setJsonText("[]");
          const token = await waitForAccessToken(15000, 250);
          if (cancelled) return;
          if (token) setIsLoadSavedOpen(true);
        }
      } catch {}
    };
    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // When opening with both ref_ademe and simul, expand the editor drawer by default
  useEffect(() => {
    try {
      const url = new URL(window.location.href);
      const hasRef = Boolean(url.searchParams.get("ref_ademe"));
      const simul = url.searchParams.get("simul");
      if (hasRef && simul && simul !== "default") {
        setIsEditorOpen(true);
      }
    } catch {}
  }, [refAdeme, simulLog]);

  const apiDebugOptions = useMemo(() => [
    { label: "none", value: undefined },
    { label: "1", value: 1 },
    { label: "2", value: 2 },
  ], []);

  useEffect(() => {
    return () => {
      try { activePollAbortRef.current?.cancel(); setIsPolling(false); } catch {}
    };
  }, []);

  // Capture the JSON snapshot when opening the editor to detect unconfirmed changes
  useEffect(() => {
    try {
      if (isEditorOpen) {
        editorOriginalTextRef.current = jsonText || "";
      }
    } catch {}
  }, [isEditorOpen]);

  const isEditorDirty = useMemo(() => {
    if (!isEditorOpen) return false;
    try {
      const a = (editorOriginalTextRef.current || "").trim();
      const b = (jsonText || "").trim();
      if (!a && !b) return false;
      try {
        const ap = a ? JSON.parse(a) : null;
        const bp = b ? JSON.parse(b) : null;
        return JSON.stringify(ap) !== JSON.stringify(bp);
      } catch {
        return a !== b;
      }
    } catch {
      return false;
    }
  }, [isEditorOpen, jsonText]);

  const isSubmitBlocked = isEditorOpen && isEditorDirty;

  function startPollingForResults(ref: string, log: string) {
    // cancel any previous polling
    try { activePollAbortRef.current?.cancel(); } catch {}
    let cancelled = false;
    activePollAbortRef.current = { cancel: () => { cancelled = true; setIsPolling(false); } };

    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const resultsHref = `https://bo.scandpe.fr/simulation/index.html?tab=results&dpe=${encodeURIComponent(ref)}`;

    setIsPolling(true);
    const tick = async () => {
      if (cancelled) return;
      try {
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", ref);
        apiUrl.searchParams.set("log", log);
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
        });
        if (res.ok) {
          const data = await res.json().catch(() => null);
          if (data && data.status === "processed") {
            setResultsUrl(resultsHref);
            cancelled = true;
            setIsPolling(false);
            return;
          }
        }
      } catch {}
      if (!cancelled) {
        window.setTimeout(tick, 1000);
      }
    };
    tick();
  }

  async function handleSaveToBackoffice() {
    try {
      if (!refAdeme || !simulLog) {
        message.error("Missing ref_ademe or simul");
        setIsSaveMenuOpen(false);
        return;
      }
      const ref = `${refAdeme}-${simulLog}`;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const apiUrl = new URL("/backoffice/redis_file_manage", base);
      setIsSaving(true);
      // eslint-disable-next-line no-console
      console.debug("[simulation] POST redis_file_manage", { url: apiUrl.toString(), ref });
      const res = await authorizedFetch(apiUrl.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json, text/plain, */*",
          "x-authorization": "dperdition",
        },
        body: JSON.stringify({ ref, text: jsonText }),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success(`saved ${simulLog}`);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error("redis_file_manage failed", err);
      message.error("save failed");
    } finally {
      setIsSaving(false);
      setIsSaveMenuOpen(false);
    }
  }

  async function fetchQueueOnce() {
    try {
      if (!refAdeme) return;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const simulName = simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
      const urlQueue = new URL("/backoffice/get_redis_detail", base);
      urlQueue.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlQueue.searchParams.set("log", `${simulName}_o3cl_queue`);
      const urlDone = new URL("/backoffice/get_redis_detail", base);
      urlDone.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlDone.searchParams.set("log", `${simulName}_o3cl_done_queue`);

      const [qres, dres] = await Promise.all([
        authorizedFetch(urlQueue.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
        authorizedFetch(urlDone.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
      ]);

      const parseItems = async (res: Response): Promise<any[]> => {
        if (!res.ok) return [];
        const data: any = await res.json().catch(() => null);
        if (Array.isArray(data?.items)) return data.items as any[];
        if (Array.isArray(data)) return data as any[];
        if (data && typeof data === "object" && Array.isArray((data as any).queue)) return (data as any).queue as any[];
        return [];
      };

      const [queueList, doneListRaw] = await Promise.all([parseItems(qres), parseItems(dres)]);
      const doneList = (doneListRaw || []).map((it: any) => ({ ...it, status: 1 }));
      const merged = [...doneList, ...queueList];
      setQueueItems(merged);
      setQueueSegments(merged.length || 0);
    } catch {}
  }

  function startQueuePolling() {
    try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    void fetchQueueOnce();
    const raw = (import.meta as any)?.env?.VITE_POLL_QUEUE_DELAY;
    const n = Number(raw);
    const delayMs = Number.isFinite(n) && n > 0 ? n : 30000;
    const id = window.setInterval(fetchQueueOnce, delayMs);
    queuePollIdRef.current = id;
  }

  useEffect(() => {
    return () => {
      try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    };
  }, []);

  useEffect(() => {
    if (!queueItems.length) return;
    const id = window.setInterval(() => setQueueNowTick((t) => t + 1), 1000);
    return () => { try { window.clearInterval(id); } catch {} };
  }, [queueItems.length]);

  async function handleSubmit() {
    try {
      const parsed = jsonText.trim() ? JSON.parse(jsonText) : {};
      const baseQuery = {
        api_debug: Boolean(apiDebug),
        skip,
        limit,
        ref_ademe: refAdeme,
      } as Record<string, unknown>;
      const query = { ...baseQuery, runs: parsed } as Record<string, unknown>;
      const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
      const body = {
        redis_db: 1,
        task: "tasks.ext_o3cl_managing.direct_scenarios",
        args: {
          ref_ademe: refAdeme,
          query,
        },
      };
      setSubmitting(true);
      // Use plain fetch to avoid adding Authorization header
      const res = await fetch(lambdaUrl, {
        method: "POST",
        headers: {
          Accept: "application/json, text/plain, */*",
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success("Submitted simulation");
      if (refAdeme) {
        const logName = `${(simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl")}_report_o3cl`;
        startPollingForResults(refAdeme, logName);
      }
      // If nb chunks > 1, also call append_scenarios
      if (Number(numChunks || 1) > 1) {
        const appendBody = {
          redis_db: 1,
          task: "tasks.ext_o3cl_managing.init_scenarios",
          args: {
            run_name: simulLog || "dev_report_o3cl",
            ref_ademe: refAdeme,
            nb_chunks: Number(numChunks || 1),
            nb_workers: Number(numWorkers || 1),
            nb_combination: 100,
            query,
          },
        } as Record<string, unknown>;
        try {
          const res2 = await fetch(lambdaUrl, {
            method: "POST",
            headers: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": "application/json",
            },
            body: JSON.stringify(appendBody),
          });
          if (!res2.ok) {
            const txt2 = await res2.text().catch(() => "");
            throw new Error(`HTTP ${res2.status} ${txt2}`);
          }
          message.success(`appending scenarios across ${Number(numChunks)} chunks`);
          // eslint-disable-next-line no-console
          console.debug("append_scenarios payload", appendBody);

          // Start queue polling for segmented progress
          startQueuePolling();
        } catch (e) {
          message.error("Failed to append scenarios");
        }
      }
      // eslint-disable-next-line no-console
      console.log("simulation payload", body);
    } catch (err) {
      message.error("Invalid JSON");
    } finally {
      setSubmitting(false);
    }
  }

  function handleConfirmWorkers() {
    const value = Number(numWorkers || 0);
    if (value > 10) {
      setWorkersError("Max 10 workers");
      setConfirmedWorkers(undefined);
      return;
    }
    if (value < 1) {
      setWorkersError("Min 1 worker");
      setConfirmedWorkers(undefined);
      return;
    }
    setWorkersError(undefined);
    setConfirmedWorkers(value);

    // Call scaling lambda
    const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
    const body = {
      redis_db: 1,
      task: "tasks.r_ecs_scaling.scale",
      args: {
        cluster: "checkdpe-dev-cluster",
        service: "checkdpe-cd-3cl-dev-service",
        desired: value,
      },
    };
    // eslint-disable-next-line no-console
    console.debug("[simulation] scaling workers", body);
    fetch(lambdaUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json, text/plain, */*" },
      body: JSON.stringify(body),
    })
      .then(async (res) => {
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} ${txt}`);
        }
        message.success(`updated workers to ${value}`);
      })
      .catch(() => {
        message.error("failed to update workers");
      });
  }

  return (
    <div style={{ minHeight: "100vh", background: "#ffffff", color: "#0b0c0f" }}>
      <TopMenu
        authLabel={userEmail || "login / sign-up"}
        authHref={(() => {
          const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
          if (configured) {
            try {
              const configuredUrl = new URL(configured);
              const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
              const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
              if (isConfiguredLocal && !isPageLocal) {
                // ignore local auth URL on non-localhost pages
              } else {
                // On non-local hosts, prefer explicit index.html so returnTo is added to the file URL
                if (!isConfiguredLocal) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  if (!endsWithHtml) {
                    const base = hasTrailingSlash ? configured.replace(/\/$/, "") : configured;
                    return base + "/index.html";
                  }
                }
                return configured;
              }
            } catch {
              return configured;
            }
          }
          if (window.location.hostname === "localhost") return "http://localhost:5173";
          return "/auth/index.html";
        })()}
        isAuthenticated={Boolean(userEmail)}
        centeredTitle={refAdeme}
        logoutHref={(() => {
          const domain = (import.meta.env.VITE_COGNITO_DOMAIN_URL as string | undefined)?.replace(/^https?:\/\//, "");
          if (!domain) return undefined;
          const clientId = import.meta.env.VITE_COGNITO_CLIENT_ID as string | undefined;
          const logoutRedirect = (import.meta.env.VITE_LOGOUT_REDIRECT_URL as string | undefined) || window.location.origin;
          if (!clientId) return undefined;
          return `https://${domain}/logout?client_id=${encodeURIComponent(clientId)}&logout_uri=${encodeURIComponent(logoutRedirect)}`;
        })()}
      />
      {/* Invisible iframe to pull session from auth origin when on different ports */}
      {!bridgeReady && (
        <iframe
          src={(() => {
            const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
            if (configured) {
              try {
                const configuredUrl = new URL(configured);
                const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
                const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
                if (!(isConfiguredLocal && !isPageLocal)) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  const base = endsWithHtml ? configured : (hasTrailingSlash ? configured.replace(/\/$/, "") + "/index.html" : configured + "/index.html");
                  return base;
                }
              } catch {
                return configured.replace(/\/$/, "") + "/index.html";
              }
            }
            if (window.location.hostname === "localhost") return "http://localhost:5173/index.html";
            return "/auth/index.html";
          })()}
          style={{ display: "none" }}
          title="session-bridge"
        />
      )}
      <div style={{ padding: 24 }}>
      <div style={{ display: "flex", alignItems: "flex-start", gap: 16 }}>
        {isEditorOpen ? (
          <DpeDrawerEditor
            inline
            open={isEditorOpen}
            onClose={() => setIsEditorOpen(false)}
            width={480}
            rootJsonText={jsonText}
            onApply={(next) => { hasUserEditedRef.current = true; flushSync(() => setJsonText(next)); }}
            apiLoadParams={refAdeme ? { baseUrl: (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr", ref_ademe: refAdeme } : undefined}
            getAccessToken={getAccessToken}
            onLoadedFromApi={(data) => {
              try {
                const text = JSON.stringify(data, null, 2);
                setJsonText((prev) => (prev?.trim() ? prev : text));
              } catch {}
            }}
            onHighlightJsonPath={({ collection, itemKey, indices }) => {
              try {
                const ta = textAreaRef.current;
                if (!ta) return;
                const text = ta.value;
                const variantPath = `dpe.logement.enveloppe.${collection}.${itemKey}`;
                let searchFrom = 0;
                let scopeArrayStart = -1;
                let scopeArrayEnd = -1;
                while (true) {
                  const varIdx = text.indexOf('"elements_variant"', searchFrom);
                  if (varIdx === -1) break;
                  const quoteIdx = text.indexOf('"', varIdx + 18);
                  const quoteEnd = quoteIdx !== -1 ? text.indexOf('"', quoteIdx + 1) : -1;
                  const value = quoteIdx !== -1 && quoteEnd !== -1 ? text.slice(quoteIdx + 1, quoteEnd) : '';
                  if (value === variantPath) {
                    const scopeKeyIdx = text.indexOf('"elements_scope"', varIdx);
                    if (scopeKeyIdx !== -1) {
                      const openBracket = text.indexOf('[', scopeKeyIdx);
                      if (openBracket !== -1) {
                        scopeArrayStart = openBracket;
                        const closeBracket = text.indexOf(']', openBracket);
                        if (closeBracket !== -1) scopeArrayEnd = closeBracket + 1;
                      }
                    }
                    break;
                  }
                  searchFrom = varIdx + 1;
                }
                if (scopeArrayStart === -1 || scopeArrayEnd === -1) return;
                const prevSelStart = ta.selectionStart;
                const prevSelEnd = ta.selectionEnd;
                const prevScrollTop = ta.scrollTop;
                const prevScrollLeft = ta.scrollLeft;
                try { (ta as any).focus({ preventScroll: true }); } catch { try { ta.focus(); } catch {} }
                try { ta.setSelectionRange(scopeArrayStart, scopeArrayEnd); } catch {}
                try { ta.scrollTop = prevScrollTop; ta.scrollLeft = prevScrollLeft; } catch {}
                window.setTimeout(() => {
                  try {
                    (ta as any).focus({ preventScroll: true });
                    ta.setSelectionRange(prevSelStart, prevSelEnd);
                    ta.scrollTop = prevScrollTop;
                    ta.scrollLeft = prevScrollLeft;
                  } catch {}
                }, 600);
              } catch {}
            }}
          />
        ) : null}

        <div style={{ flex: 1 }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12 }}>
            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
              <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Simulation</Title>
              <Button type="primary" size="large" icon={<LeftOutlined />} onClick={openEditor} disabled={isEditorOpen}>Edit</Button>
            </div>
            <Button onClick={() => setIsChainlitOpen(true)}>build with AI</Button>
          </div>
          <Paragraph style={{ color: "#4b5563", marginTop: 4 }}>Provide JSON and configure options, then submit.</Paragraph>
          {refAdeme ? (
            <div style={{ marginTop: 12 }}>
              <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
                <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 12 }}>
                  <Title level={4} style={{ margin: 0 }}>Results preview</Title>
                </div>
                <SimulationResults
                  dpeId={refAdeme}
                  getAccessToken={getAccessToken}
                  apiBaseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
                  width={720}
                  height={300}
                />
              </Card>
            </div>
          ) : null}
          
          <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
            <div style={{ display: "grid" }}>
              <textarea
                ref={textAreaRef}
                value={jsonText}
                onChange={(e) => { hasUserEditedRef.current = true; setJsonText(e.target.value); }}
                placeholder="Paste or write JSON here"
                style={{
                  minHeight: 420,
                  width: "100%",
                  background: isEditorOpen ? "#f3f4f6" : "#ffffff",
                  color: isEditorOpen ? "#6b7280" : "#111827",
                  border: "1px solid #e5e7eb",
                  borderRadius: 8,
                  padding: 12,
                  fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace",
                  fontSize: 14,
                  lineHeight: 1.45,
                  resize: "vertical",
                  cursor: isEditorOpen ? "default" : "text",
                  overflow: "auto",
                }}
                readOnly={isEditorOpen}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <Collapse
                destroyOnHidden
                items={[
                  {
                    key: "options",
                    label: "Options",
                    children: (
                      <Space direction="vertical" size={12} style={{ width: "100%" }}>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>api_debug</div>
                          <Select
                            value={apiDebug as number | undefined}
                            onChange={(v) => setApiDebug(v)}
                            allowClear
                            placeholder="none"
                            options={apiDebugOptions}
                            style={{ width: "100%" }}
                          />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>skip</div>
                          <InputNumber value={skip} onChange={(v) => setSkip(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>limit</div>
                          <InputNumber value={limit} onChange={(v) => setLimit(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb chunks</div>
                          <InputNumber value={numChunks} onChange={(v) => setNumChunks(Number(v ?? 1))} style={{ width: "100%" }} min={1} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb workers</div>
                          <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                            <InputNumber value={numWorkers} onChange={(v) => { setWorkersError(undefined); setNumWorkers(Number(v ?? 1)); }} style={{ width: 140 }} min={1} />
                            <Button size="small" onClick={handleConfirmWorkers}>ok</Button>
                            {typeof confirmedWorkers === "number" && (
                              <span style={{ color: "#059669", fontSize: 12 }}>saved: {confirmedWorkers}</span>
                            )}
                          </div>
                          {workersError && (
                            <div style={{ marginTop: 4, color: "#ef4444", fontSize: 12 }}>{workersError}</div>
                          )}
                        </div>
                      </Space>
                    ),
                  },
                ]}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <div style={{ display: "flex", gap: 8, justifyContent: "flex-end", alignItems: "center" }}>
                <Tooltip title={isSubmitBlocked ? "confirm simulation with OK (left panel), first." : undefined}>
                  <span style={{ display: "inline-block" }}>
                    <Button type="primary" onClick={handleSubmit} loading={submitting} disabled={isSubmitBlocked}>submit</Button>
                  </span>
                </Tooltip>
                <div style={{ position: "relative" }}>
                  <Button onClick={() => setIsSaveMenuOpen((v) => !v)}>...</Button>
                  {isSaveMenuOpen && (
                    <div style={{ position: "absolute", right: 0, top: "100%", background: "#fff", border: "1px solid #e5e7eb", borderRadius: 8, padding: 8, width: 260, boxShadow: "0 4px 14px rgba(0,0,0,0.08)", zIndex: 10 }}>
                    <div style={{ padding: "6px 8px", cursor: "pointer", borderRadius: 6 }} onClick={() => { setIsLoadSavedOpen(true); setIsSaveMenuOpen(false); }}>load scenario</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={() => { if (!isSaving) handleSaveToBackoffice(); }}>save {simulLog || "default"}</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={async () => {
                      if (isSaving) return;
                      const cdEnv = ((import.meta as any)?.env?.VITE_CD_ENV as string | undefined) || (import.meta.env.MODE === "development" ? "dev" : "prod");
                      const suggested = `${cdEnv}_simul_${simulLog || "test0001"}`;
                      const name = window.prompt(
                        "Save as name (format: <CD_ENV>_simul_<name>, e.g., dev_simul_test0001):",
                        suggested
                      );
                      if (!name) { setIsSaveMenuOpen(false); return; }
                      try {
                        const ref = `${refAdeme || "unknown"}-${name}`;
                        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
                        const apiUrl = new URL("/backoffice/redis_file_manage", base);
                        setIsSaving(true);
                        // eslint-disable-next-line no-console
                        console.debug("[simulation] POST redis_file_manage (save as)", { url: apiUrl.toString(), ref });
                        const res = await authorizedFetch(apiUrl.toString(), {
                          method: "POST",
                          headers: {
                            "Content-Type": "application/json",
                            Accept: "application/json, text/plain, */*",
                            "x-authorization": "dperdition",
                          },
                          body: JSON.stringify({ ref, text: jsonText }),
                        });
                        if (!res.ok) {
                          const txt = await res.text().catch(() => "");
                          throw new Error(`HTTP ${res.status} ${txt}`);
                        }
                        message.success(`saved ${name}`);
                        if (refAdeme) {
                          const { origin, pathname } = window.location;
                          const basePath = (() => {
                            try {
                              const idx = pathname.lastIndexOf("/");
                              return idx !== -1 ? pathname.slice(0, idx + 1) : "/";
                            } catch {
                              return "/";
                            }
                          })();
                          const targetUrl = `${origin}${basePath}index.html?ref_ademe=${encodeURIComponent(refAdeme)}&simul=${encodeURIComponent(name)}`;
                          window.location.href = targetUrl;
                        }
                      } catch {
                        message.error("save failed");
                      } finally {
                        setIsSaving(false);
                        setIsSaveMenuOpen(false);
                      }
                    }}>save as…</div>
                    </div>
                  )}
                </div>
              </div>
              <div style={{ marginTop: 8, display: "flex", justifyContent: "flex-end", minHeight: 24 }}>
                {!resultsUrl && isPolling && (
                  <Spin size="small" />
                )}
                {resultsUrl && (
                  <a href={resultsUrl} target="_blank" rel="noopener noreferrer" style={{ display: "inline-flex", alignItems: "center", gap: 6 }}>
                    Open simulation results <ExportOutlined />
                  </a>
                )}
              </div>
              {queueSegments > 0 && (
                <div style={{ marginTop: 12 }}>
                  <div style={{ height: 10, background: "#e5e7eb", borderRadius: 8, overflow: "hidden", display: "flex" }}>
                    {(queueItems.length ? queueItems : Array.from({ length: queueSegments })).map((item: any, idx: number) => {
                      const ts = item?.ts_started;
                      let startedAtMs = 0;
                      try {
                        if (typeof ts === "number") startedAtMs = ts > 1e12 ? ts : ts * 1000;
                        else if (typeof ts === "string") {
                          const n = Number(ts);
                          if (Number.isFinite(n)) startedAtMs = n > 1e12 ? n : n * 1000; else {
                            const t = Date.parse(ts);
                            if (!Number.isNaN(t)) startedAtMs = t;
                          }
                        }
                      } catch {}
                      const elapsedSec = Math.max(0, (Date.now() - startedAtMs) / 1000);
                      const statusNum = Number(item?.status ?? 0);
                      const pct = statusNum === 1 ? 100 : Math.max(0, Math.min(100, (elapsedSec / 60) * 100));
                      const fillColor = statusNum === 1 ? "#93c5fd" : "transparent";
                      return (
                        <div key={idx} style={{ flex: 1, display: "flex" }}>
                          <div style={{ width: `${pct}%`, background: fillColor, transition: "width 1s linear" }} />
                          {idx < queueSegments - 1 ? (
                            <div style={{ width: 2, background: "#ffffff" }} />
                          ) : null}
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              {/* editor inline panel is rendered on the right */}
            </div>
            <SimulationScenariosModal
              open={isScenariosOpen}
              onCancel={() => setIsScenariosOpen(false)}
              onLoad={(runs) => {
                try {
                  setJsonText(JSON.stringify(runs, null, 2));
                } catch {
                  // fallback to empty array
                  setJsonText(JSON.stringify([], null, 2));
                }
                setIsScenariosOpen(false);
              }}
            />
            <LoadScenarioModal
              open={isLoadSavedOpen}
              onCancel={() => setIsLoadSavedOpen(false)}
              onSelect={(payload: unknown) => {
                try {
                  // Accept payload either as normalized object { ref_ademe, label } or string "ref:label"
                  let ref: string | undefined;
                  let simul: string | undefined;
                  if (typeof payload === "string") {
                    const colon = payload.indexOf(":");
                    ref = colon !== -1 ? payload.slice(0, colon) : undefined;
                    simul = colon !== -1 ? payload.slice(colon + 1) : undefined;
                  } else if (payload && typeof payload === "object") {
                    ref = (payload as any).ref_ademe as string | undefined;
                    simul = (payload as any).label as string | undefined;
                  }
                  const url = new URL(window.location.href);
                  if (ref) url.searchParams.set("ref_ademe", ref);
                  if (simul) url.searchParams.set("simul", simul);
                  window.location.href = url.toString();
                } catch {}
                setIsLoadSavedOpen(false);
              }}
              baseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
              initialRefAdeme={refAdeme}
              getAccessToken={getAccessToken}
            />
          </Card>
        </div>

        {(() => {
          const chainlitUrl = (() => {
            const configured = import.meta.env.VITE_CHAINLIT_URL as string | undefined;
            if (configured && typeof configured === "string" && configured.trim()) return configured.trim();
            return "https://chainlit-stg.etiquettedpe.fr/chainlit";
          })();
          return (
            <ChainlitChatDrawer
              open={isChainlitOpen}
              onClose={() => setIsChainlitOpen(false)}
              title="Assistant"
              serverUrl={chainlitUrl}
              userEnv={{
                mail: "germain.blanchet@gmail.com",
                button_id: "contactez_nous",
                ref_ademe: refAdeme || "2508E0243162W",
              }}
            />
          );
        })()}

      </div>
      </div>
    </div>
  );
};



```

I added the new dependency, imported `SimulationResults`, and rendered it below the "Simulation" heading using `refAdeme` and `getAccessToken`. I'll install workspace deps so the new package resolves in the app.

```jsonc
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@acme/chainlit-client": [
        "../../packages/chainlit-client/src/index.ts"
      ],
      "@acme/simulation-results": [
        "../../packages/simulation-results/src/index.ts"
      ]
    },
    "types": [
      "vite/client"
    ]
  },
  "include": [
    "src"
  ]
}



```

```typescriptreact
import React, { useEffect, useMemo, useRef, useState } from "react";
import "./amplify";
import { authorizedFetch, waitForAccessToken, getAccessToken, setBridgeAccessToken } from "./auth";
import { Hub } from "aws-amplify/utils";
import { Button, Card, Col, Flex, Input, InputNumber, Row, Select, Space, Typography, message, Spin, Collapse, Tooltip } from "antd";
import { ExportOutlined, LeftOutlined } from "@ant-design/icons";
import { SimulationScenariosModal } from "@acme/simulation-scenarios";
import { LoadScenarioModal } from "@acme/load-scenario";
import { DpeDrawerEditor, fetchSimulationTemplateJson } from "@acme/dpe-editor";
import { SimulationResults } from "@acme/simulation-results";
import { ChainlitChatDrawer } from "@acme/chainlit-client";
import { TopMenu } from "@acme/top-menu";
import { fetchAuthSession, getCurrentUser, fetchUserAttributes } from "aws-amplify/auth";
import { flushSync } from "react-dom";

const { Title, Paragraph } = Typography;

export const App: React.FC = () => {
  const [jsonText, setJsonText] = useState<string>("{\n  \"items\": []\n}");
  const textAreaRef = useRef<HTMLTextAreaElement | null>(null);
  const [apiDebug, setApiDebug] = useState<number | undefined>(undefined);
  const [skip, setSkip] = useState<number>(1);
  const [limit, setLimit] = useState<number>(10);
  const [numChunks, setNumChunks] = useState<number>(1);
  useEffect(() => { setNumChunks(2); }, []);
  const [numWorkers, setNumWorkers] = useState<number>(1);
  const [confirmedWorkers, setConfirmedWorkers] = useState<number | undefined>(undefined);
  const [workersError, setWorkersError] = useState<string | undefined>(undefined);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [userEmail, setUserEmail] = useState<string | undefined>(undefined);
  const [bridgeReady, setBridgeReady] = useState<boolean>(false);
  const [bridgeAuthenticated, setBridgeAuthenticated] = useState<boolean>(false);
  const hasInitFetchedRef = useRef<boolean>(false);
  const hasUserEditedRef = useRef<boolean>(false);
  const [refAdeme, setRefAdeme] = useState<string | undefined>(undefined);
  const [simulLog, setSimulLog] = useState<string | undefined>(undefined);
  const [isSaveMenuOpen, setIsSaveMenuOpen] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [resultsUrl, setResultsUrl] = useState<string | undefined>(undefined);
  const activePollAbortRef = useRef<{ cancel: () => void } | null>(null);
  const [isPolling, setIsPolling] = useState<boolean>(false);
  const [isScenariosOpen, setIsScenariosOpen] = useState<boolean>(false);
  const [isLoadSavedOpen, setIsLoadSavedOpen] = useState<boolean>(false);
  const [isEditorOpen, setIsEditorOpen] = useState<boolean>(false);
  const [isChainlitOpen, setIsChainlitOpen] = useState<boolean>(false);
  const [queueSegments, setQueueSegments] = useState<number>(0);
  const [queueItems, setQueueItems] = useState<any[]>([]);
  const queuePollIdRef = useRef<number | null>(null);
  const [queueNowTick, setQueueNowTick] = useState<number>(0);
  function openEditor() { setIsEditorOpen(true); }
  const hasLoadedTemplateRef = useRef<boolean>(false);
  const editorOriginalTextRef = useRef<string>("");

  useEffect(() => {
    let isCancelled = false;
    // Listen to session bridge messages from auth app
    function onMessage(ev: MessageEvent) {
      try {
        const payload = ev.data;
        if (!payload || payload.type !== "cognito-session-bridge") return;
        const authOrigin = payload?.data?.authOrigin as string | undefined;
        // Optionally validate origin
        if (authOrigin && !ev.origin.startsWith(authOrigin)) {
          // origin mismatch – ignore
          return;
        }
        setBridgeReady(true);
        const isAuthenticated = Boolean(payload?.data?.isAuthenticated);
        const tokenFromBridge = (payload?.data?.accessToken as string | undefined) || undefined;
        if (tokenFromBridge) setBridgeAccessToken(tokenFromBridge);
        if (isAuthenticated) setBridgeAuthenticated(true);
        const emailFromBridge = (payload?.data?.email as string | undefined) || (payload?.data?.username as string | undefined);
        if (!isCancelled && emailFromBridge) {
          setUserEmail((prev) => prev || emailFromBridge);
        }
      } catch {}
    }
    window.addEventListener("message", onMessage);
    
    (async () => {
      try {
        const url = new URL(window.location.href);
        const ra = url.searchParams.get("ref_ademe") || undefined;
        const sim = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string | undefined) || undefined;
        if (!isCancelled) {
          setRefAdeme(ra);
          setSimulLog(sim);
        }
      } catch {}
      // Immediate cookie-based fallback for username/email
      try {
        const parts = document.cookie.split("; ").filter(Boolean);
        for (const part of parts) {
          const idx = part.indexOf("=");
          if (idx === -1) continue;
          const key = part.substring(0, idx);
          const val = part.substring(idx + 1);
          if (key.startsWith("CognitoIdentityServiceProvider.") && key.endsWith(".LastAuthUser")) {
            const raw = decodeURIComponent(val);
            if (raw && !isCancelled) {
              setUserEmail(raw);
              return; // found username from cookie; stop here
            }
          }
        }
      } catch {}

      // Fallback #2: decode idToken cookie to extract email claim
      try {
        const all = document.cookie.split("; ").filter(Boolean);
        const prefix = "CognitoIdentityServiceProvider.";
        for (const cookie of all) {
          const eq = cookie.indexOf("=");
          if (eq === -1) continue;
          const name = cookie.substring(0, eq);
          if (!name.startsWith(prefix) || !name.endsWith(".idToken")) continue;
          const raw = decodeURIComponent(cookie.substring(eq + 1));
          const parts = raw.split(".");
          if (parts.length >= 2) {
            const mid = parts[1]!;
            const payload = JSON.parse(atob(mid.replace(/-/g, "+").replace(/_/g, "/")));
            const emailClaim = (payload && (payload.email || payload.username)) as string | undefined;
            if (emailClaim && !isCancelled) {
              setUserEmail(emailClaim);
              break;
            }
          }
        }
      } catch {}

      try {
        // Prefer Cognito username (often the email) if available
        const { username } = await getCurrentUser();
        if (username && !isCancelled) {
          setUserEmail(username || undefined);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      // Try fetching user attributes (email) when available
      try {
        const attrs = await fetchUserAttributes();
        const emailAttr = attrs?.email as string | undefined;
        if (emailAttr && !isCancelled) {
          setUserEmail(emailAttr);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      try {
        const session = await fetchAuthSession();
        const emailClaim = (session as any)?.tokens?.idToken?.payload?.email as string | undefined;
        if (!isCancelled) setUserEmail(emailClaim ?? undefined);
      } catch {
        if (!isCancelled) setUserEmail(undefined);
      }
    })();
    return () => {
      isCancelled = true;
      window.removeEventListener("message", onMessage);
    };
  }, []);

  // Also try firing when bridge reports authenticated (helps cross-port first load)
  useEffect(() => {
    if (!bridgeAuthenticated || hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    (async () => {
      try {
        const token = await waitForAccessToken(15000, 250);
        if (!token) return;
        if (hasInitFetchedRef.current) return;
        hasInitFetchedRef.current = true;
        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", refAdeme);
        apiUrl.searchParams.set("log", simul);
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail (bridge)", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail (bridge)", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed (bridge)", err);
      }
    })();
    return () => controller.abort();
  }, [bridgeAuthenticated]);

  // On init: if URL contains simul=default, call template endpoint and initialize editor JSON
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        if (cancelled) return;
        if (hasLoadedTemplateRef.current) return;
        const url = new URL(window.location.href);
        const simul = url.searchParams.get("simul");
        if (simul !== "default") return;
        if (!refAdeme) return;
        if (hasUserEditedRef.current) return;

        const accessToken = await waitForAccessToken(15000, 250);
        if (!accessToken) return;

        const baseUrl = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const template = await fetchSimulationTemplateJson<any>({ baseUrl, ref_ademe: refAdeme, accessToken });
        if (cancelled) return;

        const sourceRuns: any[] = Array.isArray(template)
          ? template
          : (template && Array.isArray(template.runs) ? template.runs : []);

        const transformedRuns = sourceRuns.map((run) => {
          const forced = run?.parameters?.input_forced || {};
          const scenarios = Array.isArray(run?.scenarios) ? run.scenarios : [];
          const nextScenarios = scenarios.map((sc: any) => {
            const baseInput = (sc && sc.input && typeof sc.input === "object") ? sc.input : {};
            const mergedInput = { ...forced, ...baseInput };
            return { ...sc, input: mergedInput };
          });
          const { parameters, ...rest } = run || {};
          return { ...rest, scenarios: nextScenarios };
        });

        if (transformedRuns.length > 0) {
          hasLoadedTemplateRef.current = true;
          setJsonText(JSON.stringify(transformedRuns, null, 2));
        }
      } catch {
        // ignore
      }
    };

    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // On init: if URL contains ?ref_ademe=..., call backoffice endpoint (Bearer included when available)
  useEffect(() => {
    if (hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const apiUrl = new URL("/backoffice/get_redis_detail", base);
    apiUrl.searchParams.set("ref_ademe", refAdeme);
    apiUrl.searchParams.set("log", simul);

    async function doFetchOnce() {
      if (hasInitFetchedRef.current) return;
      hasInitFetchedRef.current = true;
      try {
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    }

    (async () => {
      try {
        // Wait for a valid access token before calling the endpoint
        const token = await waitForAccessToken(15000, 250);
        if (!token) {
          // eslint-disable-next-line no-console
          console.warn("[simulation] skipping get_redis_detail: no Cognito token available");
          return; // we'll rely on auth Hub events below if sign-in happens later
        }
        await doFetchOnce();
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    })();

    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh"){ doFetchOnce(); }
      } catch {}
    });

    // Poll as a safety net in case Hub events fired before subscribe
    const pollId = window.setInterval(async () => {
      try {
        if (hasInitFetchedRef.current) { window.clearInterval(pollId); return; }
        const token = await getAccessToken();
        if (token) {
          window.clearInterval(pollId);
          await doFetchOnce();
        }
      } catch {}
    }, 500);

    return () => {
      try { (removeHub as any)?.(); } catch {}
      try { window.clearInterval(pollId); } catch {}
      controller.abort();
    };
  }, []);

  // When only ref_ademe is present and no simul param, initialize editor to [] and open load modal (after token available)
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        const url = new URL(window.location.href);
        const hasRef = Boolean(url.searchParams.get("ref_ademe"));
        const hasSimul = url.searchParams.has("simul");
        if (hasRef && !hasSimul) {
          if (!hasUserEditedRef.current) setJsonText("[]");
          const token = await waitForAccessToken(15000, 250);
          if (cancelled) return;
          if (token) setIsLoadSavedOpen(true);
        }
      } catch {}
    };
    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // When opening with both ref_ademe and simul, expand the editor drawer by default
  useEffect(() => {
    try {
      const url = new URL(window.location.href);
      const hasRef = Boolean(url.searchParams.get("ref_ademe"));
      const simul = url.searchParams.get("simul");
      if (hasRef && simul && simul !== "default") {
        setIsEditorOpen(true);
      }
    } catch {}
  }, [refAdeme, simulLog]);

  const apiDebugOptions = useMemo(() => [
    { label: "none", value: undefined },
    { label: "1", value: 1 },
    { label: "2", value: 2 },
  ], []);

  useEffect(() => {
    return () => {
      try { activePollAbortRef.current?.cancel(); setIsPolling(false); } catch {}
    };
  }, []);

  // Capture the JSON snapshot when opening the editor to detect unconfirmed changes
  useEffect(() => {
    try {
      if (isEditorOpen) {
        editorOriginalTextRef.current = jsonText || "";
      }
    } catch {}
  }, [isEditorOpen]);

  const isEditorDirty = useMemo(() => {
    if (!isEditorOpen) return false;
    try {
      const a = (editorOriginalTextRef.current || "").trim();
      const b = (jsonText || "").trim();
      if (!a && !b) return false;
      try {
        const ap = a ? JSON.parse(a) : null;
        const bp = b ? JSON.parse(b) : null;
        return JSON.stringify(ap) !== JSON.stringify(bp);
      } catch {
        return a !== b;
      }
    } catch {
      return false;
    }
  }, [isEditorOpen, jsonText]);

  const isSubmitBlocked = isEditorOpen && isEditorDirty;

  function startPollingForResults(ref: string, log: string) {
    // cancel any previous polling
    try { activePollAbortRef.current?.cancel(); } catch {}
    let cancelled = false;
    activePollAbortRef.current = { cancel: () => { cancelled = true; setIsPolling(false); } };

    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const resultsHref = `https://bo.scandpe.fr/simulation/index.html?tab=results&dpe=${encodeURIComponent(ref)}`;

    setIsPolling(true);
    const tick = async () => {
      if (cancelled) return;
      try {
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", ref);
        apiUrl.searchParams.set("log", log);
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
        });
        if (res.ok) {
          const data = await res.json().catch(() => null);
          if (data && data.status === "processed") {
            setResultsUrl(resultsHref);
            cancelled = true;
            setIsPolling(false);
            return;
          }
        }
      } catch {}
      if (!cancelled) {
        window.setTimeout(tick, 1000);
      }
    };
    tick();
  }

  async function handleSaveToBackoffice() {
    try {
      if (!refAdeme || !simulLog) {
        message.error("Missing ref_ademe or simul");
        setIsSaveMenuOpen(false);
        return;
      }
      const ref = `${refAdeme}-${simulLog}`;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const apiUrl = new URL("/backoffice/redis_file_manage", base);
      setIsSaving(true);
      // eslint-disable-next-line no-console
      console.debug("[simulation] POST redis_file_manage", { url: apiUrl.toString(), ref });
      const res = await authorizedFetch(apiUrl.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json, text/plain, */*",
          "x-authorization": "dperdition",
        },
        body: JSON.stringify({ ref, text: jsonText }),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success(`saved ${simulLog}`);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error("redis_file_manage failed", err);
      message.error("save failed");
    } finally {
      setIsSaving(false);
      setIsSaveMenuOpen(false);
    }
  }

  async function fetchQueueOnce() {
    try {
      if (!refAdeme) return;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const simulName = simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
      const urlQueue = new URL("/backoffice/get_redis_detail", base);
      urlQueue.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlQueue.searchParams.set("log", `${simulName}_o3cl_queue`);
      const urlDone = new URL("/backoffice/get_redis_detail", base);
      urlDone.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlDone.searchParams.set("log", `${simulName}_o3cl_done_queue`);

      const [qres, dres] = await Promise.all([
        authorizedFetch(urlQueue.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
        authorizedFetch(urlDone.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
      ]);

      const parseItems = async (res: Response): Promise<any[]> => {
        if (!res.ok) return [];
        const data: any = await res.json().catch(() => null);
        if (Array.isArray(data?.items)) return data.items as any[];
        if (Array.isArray(data)) return data as any[];
        if (data && typeof data === "object" && Array.isArray((data as any).queue)) return (data as any).queue as any[];
        return [];
      };

      const [queueList, doneListRaw] = await Promise.all([parseItems(qres), parseItems(dres)]);
      const doneList = (doneListRaw || []).map((it: any) => ({ ...it, status: 1 }));
      const merged = [...doneList, ...queueList];
      setQueueItems(merged);
      setQueueSegments(merged.length || 0);
    } catch {}
  }

  function startQueuePolling() {
    try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    void fetchQueueOnce();
    const raw = (import.meta as any)?.env?.VITE_POLL_QUEUE_DELAY;
    const n = Number(raw);
    const delayMs = Number.isFinite(n) && n > 0 ? n : 30000;
    const id = window.setInterval(fetchQueueOnce, delayMs);
    queuePollIdRef.current = id;
  }

  useEffect(() => {
    return () => {
      try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    };
  }, []);

  useEffect(() => {
    if (!queueItems.length) return;
    const id = window.setInterval(() => setQueueNowTick((t) => t + 1), 1000);
    return () => { try { window.clearInterval(id); } catch {} };
  }, [queueItems.length]);

  async function handleSubmit() {
    try {
      const parsed = jsonText.trim() ? JSON.parse(jsonText) : {};
      const baseQuery = {
        api_debug: Boolean(apiDebug),
        skip,
        limit,
        ref_ademe: refAdeme,
      } as Record<string, unknown>;
      const query = { ...baseQuery, runs: parsed } as Record<string, unknown>;
      const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
      const body = {
        redis_db: 1,
        task: "tasks.ext_o3cl_managing.direct_scenarios",
        args: {
          ref_ademe: refAdeme,
          query,
        },
      };
      setSubmitting(true);
      // Use plain fetch to avoid adding Authorization header
      const res = await fetch(lambdaUrl, {
        method: "POST",
        headers: {
          Accept: "application/json, text/plain, */*",
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success("Submitted simulation");
      if (refAdeme) {
        const logName = `${(simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl")}_report_o3cl`;
        startPollingForResults(refAdeme, logName);
      }
      // If nb chunks > 1, also call append_scenarios
      if (Number(numChunks || 1) > 1) {
        const appendBody = {
          redis_db: 1,
          task: "tasks.ext_o3cl_managing.init_scenarios",
          args: {
            run_name: simulLog || "dev_report_o3cl",
            ref_ademe: refAdeme,
            nb_chunks: Number(numChunks || 1),
            nb_workers: Number(numWorkers || 1),
            nb_combination: 100,
            query,
          },
        } as Record<string, unknown>;
        try {
          const res2 = await fetch(lambdaUrl, {
            method: "POST",
            headers: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": "application/json",
            },
            body: JSON.stringify(appendBody),
          });
          if (!res2.ok) {
            const txt2 = await res2.text().catch(() => "");
            throw new Error(`HTTP ${res2.status} ${txt2}`);
          }
          message.success(`appending scenarios across ${Number(numChunks)} chunks`);
          // eslint-disable-next-line no-console
          console.debug("append_scenarios payload", appendBody);

          // Start queue polling for segmented progress
          startQueuePolling();
        } catch (e) {
          message.error("Failed to append scenarios");
        }
      }
      // eslint-disable-next-line no-console
      console.log("simulation payload", body);
    } catch (err) {
      message.error("Invalid JSON");
    } finally {
      setSubmitting(false);
    }
  }

  function handleConfirmWorkers() {
    const value = Number(numWorkers || 0);
    if (value > 10) {
      setWorkersError("Max 10 workers");
      setConfirmedWorkers(undefined);
      return;
    }
    if (value < 1) {
      setWorkersError("Min 1 worker");
      setConfirmedWorkers(undefined);
      return;
    }
    setWorkersError(undefined);
    setConfirmedWorkers(value);

    // Call scaling lambda
    const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
    const body = {
      redis_db: 1,
      task: "tasks.r_ecs_scaling.scale",
      args: {
        cluster: "checkdpe-dev-cluster",
        service: "checkdpe-cd-3cl-dev-service",
        desired: value,
      },
    };
    // eslint-disable-next-line no-console
    console.debug("[simulation] scaling workers", body);
    fetch(lambdaUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json, text/plain, */*" },
      body: JSON.stringify(body),
    })
      .then(async (res) => {
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} ${txt}`);
        }
        message.success(`updated workers to ${value}`);
      })
      .catch(() => {
        message.error("failed to update workers");
      });
  }

  return (
    <div style={{ minHeight: "100vh", background: "#ffffff", color: "#0b0c0f" }}>
      <TopMenu
        authLabel={userEmail || "login / sign-up"}
        authHref={(() => {
          const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
          if (configured) {
            try {
              const configuredUrl = new URL(configured);
              const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
              const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
              if (isConfiguredLocal && !isPageLocal) {
                // ignore local auth URL on non-localhost pages
              } else {
                // On non-local hosts, prefer explicit index.html so returnTo is added to the file URL
                if (!isConfiguredLocal) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  if (!endsWithHtml) {
                    const base = hasTrailingSlash ? configured.replace(/\/$/, "") : configured;
                    return base + "/index.html";
                  }
                }
                return configured;
              }
            } catch {
              return configured;
            }
          }
          if (window.location.hostname === "localhost") return "http://localhost:5173";
          return "/auth/index.html";
        })()}
        isAuthenticated={Boolean(userEmail)}
        centeredTitle={refAdeme}
        logoutHref={(() => {
          const domain = (import.meta.env.VITE_COGNITO_DOMAIN_URL as string | undefined)?.replace(/^https?:\/\//, "");
          if (!domain) return undefined;
          const clientId = import.meta.env.VITE_COGNITO_CLIENT_ID as string | undefined;
          const logoutRedirect = (import.meta.env.VITE_LOGOUT_REDIRECT_URL as string | undefined) || window.location.origin;
          if (!clientId) return undefined;
          return `https://${domain}/logout?client_id=${encodeURIComponent(clientId)}&logout_uri=${encodeURIComponent(logoutRedirect)}`;
        })()}
      />
      {/* Invisible iframe to pull session from auth origin when on different ports */}
      {!bridgeReady && (
        <iframe
          src={(() => {
            const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
            if (configured) {
              try {
                const configuredUrl = new URL(configured);
                const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
                const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
                if (!(isConfiguredLocal && !isPageLocal)) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  const base = endsWithHtml ? configured : (hasTrailingSlash ? configured.replace(/\/$/, "") + "/index.html" : configured + "/index.html");
                  return base;
                }
              } catch {
                return configured.replace(/\/$/, "") + "/index.html";
              }
            }
            if (window.location.hostname === "localhost") return "http://localhost:5173/index.html";
            return "/auth/index.html";
          })()}
          style={{ display: "none" }}
          title="session-bridge"
        />
      )}
      <div style={{ padding: 24 }}>
      <div style={{ display: "flex", alignItems: "flex-start", gap: 16 }}>
        {isEditorOpen ? (
          <DpeDrawerEditor
            inline
            open={isEditorOpen}
            onClose={() => setIsEditorOpen(false)}
            width={480}
            rootJsonText={jsonText}
            onApply={(next) => { hasUserEditedRef.current = true; flushSync(() => setJsonText(next)); }}
            apiLoadParams={refAdeme ? { baseUrl: (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr", ref_ademe: refAdeme } : undefined}
            getAccessToken={getAccessToken}
            onLoadedFromApi={(data) => {
              try {
                const text = JSON.stringify(data, null, 2);
                setJsonText((prev) => (prev?.trim() ? prev : text));
              } catch {}
            }}
            onHighlightJsonPath={({ collection, itemKey, indices }) => {
              try {
                const ta = textAreaRef.current;
                if (!ta) return;
                const text = ta.value;
                const variantPath = `dpe.logement.enveloppe.${collection}.${itemKey}`;
                let searchFrom = 0;
                let scopeArrayStart = -1;
                let scopeArrayEnd = -1;
                while (true) {
                  const varIdx = text.indexOf('"elements_variant"', searchFrom);
                  if (varIdx === -1) break;
                  const quoteIdx = text.indexOf('"', varIdx + 18);
                  const quoteEnd = quoteIdx !== -1 ? text.indexOf('"', quoteIdx + 1) : -1;
                  const value = quoteIdx !== -1 && quoteEnd !== -1 ? text.slice(quoteIdx + 1, quoteEnd) : '';
                  if (value === variantPath) {
                    const scopeKeyIdx = text.indexOf('"elements_scope"', varIdx);
                    if (scopeKeyIdx !== -1) {
                      const openBracket = text.indexOf('[', scopeKeyIdx);
                      if (openBracket !== -1) {
                        scopeArrayStart = openBracket;
                        const closeBracket = text.indexOf(']', openBracket);
                        if (closeBracket !== -1) scopeArrayEnd = closeBracket + 1;
                      }
                    }
                    break;
                  }
                  searchFrom = varIdx + 1;
                }
                if (scopeArrayStart === -1 || scopeArrayEnd === -1) return;
                const prevSelStart = ta.selectionStart;
                const prevSelEnd = ta.selectionEnd;
                const prevScrollTop = ta.scrollTop;
                const prevScrollLeft = ta.scrollLeft;
                try { (ta as any).focus({ preventScroll: true }); } catch { try { ta.focus(); } catch {} }
                try { ta.setSelectionRange(scopeArrayStart, scopeArrayEnd); } catch {}
                try { ta.scrollTop = prevScrollTop; ta.scrollLeft = prevScrollLeft; } catch {}
                window.setTimeout(() => {
                  try {
                    (ta as any).focus({ preventScroll: true });
                    ta.setSelectionRange(prevSelStart, prevSelEnd);
                    ta.scrollTop = prevScrollTop;
                    ta.scrollLeft = prevScrollLeft;
                  } catch {}
                }, 600);
              } catch {}
            }}
          />
        ) : null}

        <div style={{ flex: 1 }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12 }}>
            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
              <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Simulation</Title>
              <Button type="primary" size="large" icon={<LeftOutlined />} onClick={openEditor} disabled={isEditorOpen}>Edit</Button>
            </div>
            <Button onClick={() => setIsChainlitOpen(true)}>build with AI</Button>
          </div>
          <Paragraph style={{ color: "#4b5563", marginTop: 4 }}>Provide JSON and configure options, then submit.</Paragraph>
          {refAdeme ? (
            <div style={{ marginTop: 12 }}>
              <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
                <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 12 }}>
                  <Title level={4} style={{ margin: 0 }}>Results preview</Title>
                </div>
                <SimulationResults
                  dpeId={refAdeme}
                  getAccessToken={async () => (await getAccessToken()) || undefined}
                  apiBaseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
                  width={720}
                  height={300}
                />
              </Card>
            </div>
          ) : null}
          
          <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
            <div style={{ display: "grid" }}>
              <textarea
                ref={textAreaRef}
                value={jsonText}
                onChange={(e) => { hasUserEditedRef.current = true; setJsonText(e.target.value); }}
                placeholder="Paste or write JSON here"
                style={{
                  minHeight: 420,
                  width: "100%",
                  background: isEditorOpen ? "#f3f4f6" : "#ffffff",
                  color: isEditorOpen ? "#6b7280" : "#111827",
                  border: "1px solid #e5e7eb",
                  borderRadius: 8,
                  padding: 12,
                  fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace",
                  fontSize: 14,
                  lineHeight: 1.45,
                  resize: "vertical",
                  cursor: isEditorOpen ? "default" : "text",
                  overflow: "auto",
                }}
                readOnly={isEditorOpen}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <Collapse
                destroyOnHidden
                items={[
                  {
                    key: "options",
                    label: "Options",
                    children: (
                      <Space direction="vertical" size={12} style={{ width: "100%" }}>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>api_debug</div>
                          <Select
                            value={apiDebug as number | undefined}
                            onChange={(v) => setApiDebug(v)}
                            allowClear
                            placeholder="none"
                            options={apiDebugOptions}
                            style={{ width: "100%" }}
                          />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>skip</div>
                          <InputNumber value={skip} onChange={(v) => setSkip(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>limit</div>
                          <InputNumber value={limit} onChange={(v) => setLimit(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb chunks</div>
                          <InputNumber value={numChunks} onChange={(v) => setNumChunks(Number(v ?? 1))} style={{ width: "100%" }} min={1} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb workers</div>
                          <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                            <InputNumber value={numWorkers} onChange={(v) => { setWorkersError(undefined); setNumWorkers(Number(v ?? 1)); }} style={{ width: 140 }} min={1} />
                            <Button size="small" onClick={handleConfirmWorkers}>ok</Button>
                            {typeof confirmedWorkers === "number" && (
                              <span style={{ color: "#059669", fontSize: 12 }}>saved: {confirmedWorkers}</span>
                            )}
                          </div>
                          {workersError && (
                            <div style={{ marginTop: 4, color: "#ef4444", fontSize: 12 }}>{workersError}</div>
                          )}
                        </div>
                      </Space>
                    ),
                  },
                ]}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <div style={{ display: "flex", gap: 8, justifyContent: "flex-end", alignItems: "center" }}>
                <Tooltip title={isSubmitBlocked ? "confirm simulation with OK (left panel), first." : undefined}>
                  <span style={{ display: "inline-block" }}>
                    <Button type="primary" onClick={handleSubmit} loading={submitting} disabled={isSubmitBlocked}>submit</Button>
                  </span>
                </Tooltip>
                <div style={{ position: "relative" }}>
                  <Button onClick={() => setIsSaveMenuOpen((v) => !v)}>...</Button>
                  {isSaveMenuOpen && (
                    <div style={{ position: "absolute", right: 0, top: "100%", background: "#fff", border: "1px solid #e5e7eb", borderRadius: 8, padding: 8, width: 260, boxShadow: "0 4px 14px rgba(0,0,0,0.08)", zIndex: 10 }}>
                    <div style={{ padding: "6px 8px", cursor: "pointer", borderRadius: 6 }} onClick={() => { setIsLoadSavedOpen(true); setIsSaveMenuOpen(false); }}>load scenario</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={() => { if (!isSaving) handleSaveToBackoffice(); }}>save {simulLog || "default"}</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={async () => {
                      if (isSaving) return;
                      const cdEnv = ((import.meta as any)?.env?.VITE_CD_ENV as string | undefined) || (import.meta.env.MODE === "development" ? "dev" : "prod");
                      const suggested = `${cdEnv}_simul_${simulLog || "test0001"}`;
                      const name = window.prompt(
                        "Save as name (format: <CD_ENV>_simul_<name>, e.g., dev_simul_test0001):",
                        suggested
                      );
                      if (!name) { setIsSaveMenuOpen(false); return; }
                      try {
                        const ref = `${refAdeme || "unknown"}-${name}`;
                        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
                        const apiUrl = new URL("/backoffice/redis_file_manage", base);
                        setIsSaving(true);
                        // eslint-disable-next-line no-console
                        console.debug("[simulation] POST redis_file_manage (save as)", { url: apiUrl.toString(), ref });
                        const res = await authorizedFetch(apiUrl.toString(), {
                          method: "POST",
                          headers: {
                            "Content-Type": "application/json",
                            Accept: "application/json, text/plain, */*",
                            "x-authorization": "dperdition",
                          },
                          body: JSON.stringify({ ref, text: jsonText }),
                        });
                        if (!res.ok) {
                          const txt = await res.text().catch(() => "");
                          throw new Error(`HTTP ${res.status} ${txt}`);
                        }
                        message.success(`saved ${name}`);
                        if (refAdeme) {
                          const { origin, pathname } = window.location;
                          const basePath = (() => {
                            try {
                              const idx = pathname.lastIndexOf("/");
                              return idx !== -1 ? pathname.slice(0, idx + 1) : "/";
                            } catch {
                              return "/";
                            }
                          })();
                          const targetUrl = `${origin}${basePath}index.html?ref_ademe=${encodeURIComponent(refAdeme)}&simul=${encodeURIComponent(name)}`;
                          window.location.href = targetUrl;
                        }
                      } catch {
                        message.error("save failed");
                      } finally {
                        setIsSaving(false);
                        setIsSaveMenuOpen(false);
                      }
                    }}>save as…</div>
                    </div>
                  )}
                </div>
              </div>
              <div style={{ marginTop: 8, display: "flex", justifyContent: "flex-end", minHeight: 24 }}>
                {!resultsUrl && isPolling && (
                  <Spin size="small" />
                )}
                {resultsUrl && (
                  <a href={resultsUrl} target="_blank" rel="noopener noreferrer" style={{ display: "inline-flex", alignItems: "center", gap: 6 }}>
                    Open simulation results <ExportOutlined />
                  </a>
                )}
              </div>
              {queueSegments > 0 && (
                <div style={{ marginTop: 12 }}>
                  <div style={{ height: 10, background: "#e5e7eb", borderRadius: 8, overflow: "hidden", display: "flex" }}>
                    {(queueItems.length ? queueItems : Array.from({ length: queueSegments })).map((item: any, idx: number) => {
                      const ts = item?.ts_started;
                      let startedAtMs = 0;
                      try {
                        if (typeof ts === "number") startedAtMs = ts > 1e12 ? ts : ts * 1000;
                        else if (typeof ts === "string") {
                          const n = Number(ts);
                          if (Number.isFinite(n)) startedAtMs = n > 1e12 ? n : n * 1000; else {
                            const t = Date.parse(ts);
                            if (!Number.isNaN(t)) startedAtMs = t;
                          }
                        }
                      } catch {}
                      const elapsedSec = Math.max(0, (Date.now() - startedAtMs) / 1000);
                      const statusNum = Number(item?.status ?? 0);
                      const pct = statusNum === 1 ? 100 : Math.max(0, Math.min(100, (elapsedSec / 60) * 100));
                      const fillColor = statusNum === 1 ? "#93c5fd" : "transparent";
                      return (
                        <div key={idx} style={{ flex: 1, display: "flex" }}>
                          <div style={{ width: `${pct}%`, background: fillColor, transition: "width 1s linear" }} />
                          {idx < queueSegments - 1 ? (
                            <div style={{ width: 2, background: "#ffffff" }} />
                          ) : null}
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              {/* editor inline panel is rendered on the right */}
            </div>
            <SimulationScenariosModal
              open={isScenariosOpen}
              onCancel={() => setIsScenariosOpen(false)}
              onLoad={(runs) => {
                try {
                  setJsonText(JSON.stringify(runs, null, 2));
                } catch {
                  // fallback to empty array
                  setJsonText(JSON.stringify([], null, 2));
                }
                setIsScenariosOpen(false);
              }}
            />
            <LoadScenarioModal
              open={isLoadSavedOpen}
              onCancel={() => setIsLoadSavedOpen(false)}
              onSelect={(payload: unknown) => {
                try {
                  // Accept payload either as normalized object { ref_ademe, label } or string "ref:label"
                  let ref: string | undefined;
                  let simul: string | undefined;
                  if (typeof payload === "string") {
                    const colon = payload.indexOf(":");
                    ref = colon !== -1 ? payload.slice(0, colon) : undefined;
                    simul = colon !== -1 ? payload.slice(colon + 1) : undefined;
                  } else if (payload && typeof payload === "object") {
                    ref = (payload as any).ref_ademe as string | undefined;
                    simul = (payload as any).label as string | undefined;
                  }
                  const url = new URL(window.location.href);
                  if (ref) url.searchParams.set("ref_ademe", ref);
                  if (simul) url.searchParams.set("simul", simul);
                  window.location.href = url.toString();
                } catch {}
                setIsLoadSavedOpen(false);
              }}
              baseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
              initialRefAdeme={refAdeme}
              getAccessToken={getAccessToken}
            />
          </Card>
        </div>

        {(() => {
          const chainlitUrl = (() => {
            const configured = import.meta.env.VITE_CHAINLIT_URL as string | undefined;
            if (configured && typeof configured === "string" && configured.trim()) return configured.trim();
            return "https://chainlit-stg.etiquettedpe.fr/chainlit";
          })();
          return (
            <ChainlitChatDrawer
              open={isChainlitOpen}
              onClose={() => setIsChainlitOpen(false)}
              title="Assistant"
              serverUrl={chainlitUrl}
              userEnv={{
                mail: "germain.blanchet@gmail.com",
                button_id: "contactez_nous",
                ref_ademe: refAdeme || "2508E0243162W",
              }}
            />
          );
        })()}

      </div>
      </div>
    </div>
  );
};



```

- Inserted `@acme/simulation-results` into the simul app:
  - Added dependency in `apps/simul/package.json`.
  - Added TS path mapping in `apps/simul/tsconfig.json`.
  - Imported `SimulationResults` in `apps/simul/src/App.tsx`.
  - Rendered it right under the “Simulation” title inside a `Card`, using `refAdeme` as `dpeId`, your `getAccessToken` (wrapped to return `undefined` instead of `null`), and `VITE_BACKOFFICE_API_URL` as `apiBaseUrl`.

Usage in `App.tsx`:
```startLine:endLine:/Volumes/privateGg/ai-microfront-ant/apps/simul/src/App.tsx
848:            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
849:              <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Simulation</Title>
850:              <Button type="primary" size="large" icon={<LeftOutlined />} onClick={openEditor} disabled={isEditorOpen}>Edit</Button>
851:            </div>
852:            <Button onClick={() => setIsChainlitOpen(true)}>build with AI</Button>
853:          </div>
854:          <Paragraph style={{ color: "#4b5563", marginTop: 4 }}>Provide JSON and configure options, then submit.</Paragraph>
855:          {refAdeme ? (
856:            <div style={{ marginTop: 12 }}>
857:              <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
858:                <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 12 }}>
859:                  <Title level={4} style={{ margin: 0 }}>Results preview</Title>
860:                </div>
861:                <SimulationResults
862:                  dpeId={refAdeme}
863:                  getAccessToken={async () => (await getAccessToken()) || undefined}
864:                  apiBaseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
865:                  width={720}
866:                  height={300}
867:                />
868:              </Card>
869:            </div>
870:          ) : null}
```

- All lints pass. You can now run the simul app; the component will fetch `GET /backoffice/simul_graph?dpe_id=<refAdeme>` with Bearer token and render a D3 line chart.

```typescriptreact
848:            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
849:              <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Simulation</Title>
850:              <Button type="primary" size="large" icon={<LeftOutlined />} onClick={openEditor} disabled={isEditorOpen}>Edit</Button>
851:            </div>
852:            <Button onClick={() => setIsChainlitOpen(true)}>build with AI</Button>
853:          </div>
854:          <Paragraph style={{ color: "#4b5563", marginTop: 4 }}>Provide JSON and configure options, then submit.</Paragraph>
855:          {refAdeme ? (
856:            <div style={{ marginTop: 12 }}>
857:              <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
858:                <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 12 }}>
859:                  <Title level={4} style={{ margin: 0 }}>Results preview</Title>
860:                </div>
861:                <SimulationResults
862:                  dpeId={refAdeme}
863:                  getAccessToken={async () => (await getAccessToken()) || undefined}
864:                  apiBaseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
865:                  width={720}
866:                  height={300}
867:                />
868:              </Card>
869:            </div>
870:          ) : null}
```

---

**User**

Result preview to go all the way under "submit" and take a title same size/style as "simulation" one

---

**Cursor**

I'll move the results preview section to below the submit area, remove the earlier insertion under the title, and update the header to use the same Title level and style as "Simulation". Then I'll run a lint check on the file.

```typescriptreact
import React, { useEffect, useMemo, useRef, useState } from "react";
import "./amplify";
import { authorizedFetch, waitForAccessToken, getAccessToken, setBridgeAccessToken } from "./auth";
import { Hub } from "aws-amplify/utils";
import { Button, Card, Col, Flex, Input, InputNumber, Row, Select, Space, Typography, message, Spin, Collapse, Tooltip } from "antd";
import { ExportOutlined, LeftOutlined } from "@ant-design/icons";
import { SimulationScenariosModal } from "@acme/simulation-scenarios";
import { LoadScenarioModal } from "@acme/load-scenario";
import { DpeDrawerEditor, fetchSimulationTemplateJson } from "@acme/dpe-editor";
import { SimulationResults } from "@acme/simulation-results";
import { ChainlitChatDrawer } from "@acme/chainlit-client";
import { TopMenu } from "@acme/top-menu";
import { fetchAuthSession, getCurrentUser, fetchUserAttributes } from "aws-amplify/auth";
import { flushSync } from "react-dom";

const { Title, Paragraph } = Typography;

export const App: React.FC = () => {
  const [jsonText, setJsonText] = useState<string>("{\n  \"items\": []\n}");
  const textAreaRef = useRef<HTMLTextAreaElement | null>(null);
  const [apiDebug, setApiDebug] = useState<number | undefined>(undefined);
  const [skip, setSkip] = useState<number>(1);
  const [limit, setLimit] = useState<number>(10);
  const [numChunks, setNumChunks] = useState<number>(1);
  useEffect(() => { setNumChunks(2); }, []);
  const [numWorkers, setNumWorkers] = useState<number>(1);
  const [confirmedWorkers, setConfirmedWorkers] = useState<number | undefined>(undefined);
  const [workersError, setWorkersError] = useState<string | undefined>(undefined);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [userEmail, setUserEmail] = useState<string | undefined>(undefined);
  const [bridgeReady, setBridgeReady] = useState<boolean>(false);
  const [bridgeAuthenticated, setBridgeAuthenticated] = useState<boolean>(false);
  const hasInitFetchedRef = useRef<boolean>(false);
  const hasUserEditedRef = useRef<boolean>(false);
  const [refAdeme, setRefAdeme] = useState<string | undefined>(undefined);
  const [simulLog, setSimulLog] = useState<string | undefined>(undefined);
  const [isSaveMenuOpen, setIsSaveMenuOpen] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [resultsUrl, setResultsUrl] = useState<string | undefined>(undefined);
  const activePollAbortRef = useRef<{ cancel: () => void } | null>(null);
  const [isPolling, setIsPolling] = useState<boolean>(false);
  const [isScenariosOpen, setIsScenariosOpen] = useState<boolean>(false);
  const [isLoadSavedOpen, setIsLoadSavedOpen] = useState<boolean>(false);
  const [isEditorOpen, setIsEditorOpen] = useState<boolean>(false);
  const [isChainlitOpen, setIsChainlitOpen] = useState<boolean>(false);
  const [queueSegments, setQueueSegments] = useState<number>(0);
  const [queueItems, setQueueItems] = useState<any[]>([]);
  const queuePollIdRef = useRef<number | null>(null);
  const [queueNowTick, setQueueNowTick] = useState<number>(0);
  function openEditor() { setIsEditorOpen(true); }
  const hasLoadedTemplateRef = useRef<boolean>(false);
  const editorOriginalTextRef = useRef<string>("");

  useEffect(() => {
    let isCancelled = false;
    // Listen to session bridge messages from auth app
    function onMessage(ev: MessageEvent) {
      try {
        const payload = ev.data;
        if (!payload || payload.type !== "cognito-session-bridge") return;
        const authOrigin = payload?.data?.authOrigin as string | undefined;
        // Optionally validate origin
        if (authOrigin && !ev.origin.startsWith(authOrigin)) {
          // origin mismatch – ignore
          return;
        }
        setBridgeReady(true);
        const isAuthenticated = Boolean(payload?.data?.isAuthenticated);
        const tokenFromBridge = (payload?.data?.accessToken as string | undefined) || undefined;
        if (tokenFromBridge) setBridgeAccessToken(tokenFromBridge);
        if (isAuthenticated) setBridgeAuthenticated(true);
        const emailFromBridge = (payload?.data?.email as string | undefined) || (payload?.data?.username as string | undefined);
        if (!isCancelled && emailFromBridge) {
          setUserEmail((prev) => prev || emailFromBridge);
        }
      } catch {}
    }
    window.addEventListener("message", onMessage);
    
    (async () => {
      try {
        const url = new URL(window.location.href);
        const ra = url.searchParams.get("ref_ademe") || undefined;
        const sim = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string | undefined) || undefined;
        if (!isCancelled) {
          setRefAdeme(ra);
          setSimulLog(sim);
        }
      } catch {}
      // Immediate cookie-based fallback for username/email
      try {
        const parts = document.cookie.split("; ").filter(Boolean);
        for (const part of parts) {
          const idx = part.indexOf("=");
          if (idx === -1) continue;
          const key = part.substring(0, idx);
          const val = part.substring(idx + 1);
          if (key.startsWith("CognitoIdentityServiceProvider.") && key.endsWith(".LastAuthUser")) {
            const raw = decodeURIComponent(val);
            if (raw && !isCancelled) {
              setUserEmail(raw);
              return; // found username from cookie; stop here
            }
          }
        }
      } catch {}

      // Fallback #2: decode idToken cookie to extract email claim
      try {
        const all = document.cookie.split("; ").filter(Boolean);
        const prefix = "CognitoIdentityServiceProvider.";
        for (const cookie of all) {
          const eq = cookie.indexOf("=");
          if (eq === -1) continue;
          const name = cookie.substring(0, eq);
          if (!name.startsWith(prefix) || !name.endsWith(".idToken")) continue;
          const raw = decodeURIComponent(cookie.substring(eq + 1));
          const parts = raw.split(".");
          if (parts.length >= 2) {
            const mid = parts[1]!;
            const payload = JSON.parse(atob(mid.replace(/-/g, "+").replace(/_/g, "/")));
            const emailClaim = (payload && (payload.email || payload.username)) as string | undefined;
            if (emailClaim && !isCancelled) {
              setUserEmail(emailClaim);
              break;
            }
          }
        }
      } catch {}

      try {
        // Prefer Cognito username (often the email) if available
        const { username } = await getCurrentUser();
        if (username && !isCancelled) {
          setUserEmail(username || undefined);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      // Try fetching user attributes (email) when available
      try {
        const attrs = await fetchUserAttributes();
        const emailAttr = attrs?.email as string | undefined;
        if (emailAttr && !isCancelled) {
          setUserEmail(emailAttr);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      try {
        const session = await fetchAuthSession();
        const emailClaim = (session as any)?.tokens?.idToken?.payload?.email as string | undefined;
        if (!isCancelled) setUserEmail(emailClaim ?? undefined);
      } catch {
        if (!isCancelled) setUserEmail(undefined);
      }
    })();
    return () => {
      isCancelled = true;
      window.removeEventListener("message", onMessage);
    };
  }, []);

  // Also try firing when bridge reports authenticated (helps cross-port first load)
  useEffect(() => {
    if (!bridgeAuthenticated || hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    (async () => {
      try {
        const token = await waitForAccessToken(15000, 250);
        if (!token) return;
        if (hasInitFetchedRef.current) return;
        hasInitFetchedRef.current = true;
        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", refAdeme);
        apiUrl.searchParams.set("log", simul);
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail (bridge)", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail (bridge)", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed (bridge)", err);
      }
    })();
    return () => controller.abort();
  }, [bridgeAuthenticated]);

  // On init: if URL contains simul=default, call template endpoint and initialize editor JSON
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        if (cancelled) return;
        if (hasLoadedTemplateRef.current) return;
        const url = new URL(window.location.href);
        const simul = url.searchParams.get("simul");
        if (simul !== "default") return;
        if (!refAdeme) return;
        if (hasUserEditedRef.current) return;

        const accessToken = await waitForAccessToken(15000, 250);
        if (!accessToken) return;

        const baseUrl = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const template = await fetchSimulationTemplateJson<any>({ baseUrl, ref_ademe: refAdeme, accessToken });
        if (cancelled) return;

        const sourceRuns: any[] = Array.isArray(template)
          ? template
          : (template && Array.isArray(template.runs) ? template.runs : []);

        const transformedRuns = sourceRuns.map((run) => {
          const forced = run?.parameters?.input_forced || {};
          const scenarios = Array.isArray(run?.scenarios) ? run.scenarios : [];
          const nextScenarios = scenarios.map((sc: any) => {
            const baseInput = (sc && sc.input && typeof sc.input === "object") ? sc.input : {};
            const mergedInput = { ...forced, ...baseInput };
            return { ...sc, input: mergedInput };
          });
          const { parameters, ...rest } = run || {};
          return { ...rest, scenarios: nextScenarios };
        });

        if (transformedRuns.length > 0) {
          hasLoadedTemplateRef.current = true;
          setJsonText(JSON.stringify(transformedRuns, null, 2));
        }
      } catch {
        // ignore
      }
    };

    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // On init: if URL contains ?ref_ademe=..., call backoffice endpoint (Bearer included when available)
  useEffect(() => {
    if (hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const apiUrl = new URL("/backoffice/get_redis_detail", base);
    apiUrl.searchParams.set("ref_ademe", refAdeme);
    apiUrl.searchParams.set("log", simul);

    async function doFetchOnce() {
      if (hasInitFetchedRef.current) return;
      hasInitFetchedRef.current = true;
      try {
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    }

    (async () => {
      try {
        // Wait for a valid access token before calling the endpoint
        const token = await waitForAccessToken(15000, 250);
        if (!token) {
          // eslint-disable-next-line no-console
          console.warn("[simulation] skipping get_redis_detail: no Cognito token available");
          return; // we'll rely on auth Hub events below if sign-in happens later
        }
        await doFetchOnce();
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    })();

    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh"){ doFetchOnce(); }
      } catch {}
    });

    // Poll as a safety net in case Hub events fired before subscribe
    const pollId = window.setInterval(async () => {
      try {
        if (hasInitFetchedRef.current) { window.clearInterval(pollId); return; }
        const token = await getAccessToken();
        if (token) {
          window.clearInterval(pollId);
          await doFetchOnce();
        }
      } catch {}
    }, 500);

    return () => {
      try { (removeHub as any)?.(); } catch {}
      try { window.clearInterval(pollId); } catch {}
      controller.abort();
    };
  }, []);

  // When only ref_ademe is present and no simul param, initialize editor to [] and open load modal (after token available)
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        const url = new URL(window.location.href);
        const hasRef = Boolean(url.searchParams.get("ref_ademe"));
        const hasSimul = url.searchParams.has("simul");
        if (hasRef && !hasSimul) {
          if (!hasUserEditedRef.current) setJsonText("[]");
          const token = await waitForAccessToken(15000, 250);
          if (cancelled) return;
          if (token) setIsLoadSavedOpen(true);
        }
      } catch {}
    };
    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // When opening with both ref_ademe and simul, expand the editor drawer by default
  useEffect(() => {
    try {
      const url = new URL(window.location.href);
      const hasRef = Boolean(url.searchParams.get("ref_ademe"));
      const simul = url.searchParams.get("simul");
      if (hasRef && simul && simul !== "default") {
        setIsEditorOpen(true);
      }
    } catch {}
  }, [refAdeme, simulLog]);

  const apiDebugOptions = useMemo(() => [
    { label: "none", value: undefined },
    { label: "1", value: 1 },
    { label: "2", value: 2 },
  ], []);

  useEffect(() => {
    return () => {
      try { activePollAbortRef.current?.cancel(); setIsPolling(false); } catch {}
    };
  }, []);

  // Capture the JSON snapshot when opening the editor to detect unconfirmed changes
  useEffect(() => {
    try {
      if (isEditorOpen) {
        editorOriginalTextRef.current = jsonText || "";
      }
    } catch {}
  }, [isEditorOpen]);

  const isEditorDirty = useMemo(() => {
    if (!isEditorOpen) return false;
    try {
      const a = (editorOriginalTextRef.current || "").trim();
      const b = (jsonText || "").trim();
      if (!a && !b) return false;
      try {
        const ap = a ? JSON.parse(a) : null;
        const bp = b ? JSON.parse(b) : null;
        return JSON.stringify(ap) !== JSON.stringify(bp);
      } catch {
        return a !== b;
      }
    } catch {
      return false;
    }
  }, [isEditorOpen, jsonText]);

  const isSubmitBlocked = isEditorOpen && isEditorDirty;

  function startPollingForResults(ref: string, log: string) {
    // cancel any previous polling
    try { activePollAbortRef.current?.cancel(); } catch {}
    let cancelled = false;
    activePollAbortRef.current = { cancel: () => { cancelled = true; setIsPolling(false); } };

    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const resultsHref = `https://bo.scandpe.fr/simulation/index.html?tab=results&dpe=${encodeURIComponent(ref)}`;

    setIsPolling(true);
    const tick = async () => {
      if (cancelled) return;
      try {
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", ref);
        apiUrl.searchParams.set("log", log);
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
        });
        if (res.ok) {
          const data = await res.json().catch(() => null);
          if (data && data.status === "processed") {
            setResultsUrl(resultsHref);
            cancelled = true;
            setIsPolling(false);
            return;
          }
        }
      } catch {}
      if (!cancelled) {
        window.setTimeout(tick, 1000);
      }
    };
    tick();
  }

  async function handleSaveToBackoffice() {
    try {
      if (!refAdeme || !simulLog) {
        message.error("Missing ref_ademe or simul");
        setIsSaveMenuOpen(false);
        return;
      }
      const ref = `${refAdeme}-${simulLog}`;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const apiUrl = new URL("/backoffice/redis_file_manage", base);
      setIsSaving(true);
      // eslint-disable-next-line no-console
      console.debug("[simulation] POST redis_file_manage", { url: apiUrl.toString(), ref });
      const res = await authorizedFetch(apiUrl.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json, text/plain, */*",
          "x-authorization": "dperdition",
        },
        body: JSON.stringify({ ref, text: jsonText }),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success(`saved ${simulLog}`);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error("redis_file_manage failed", err);
      message.error("save failed");
    } finally {
      setIsSaving(false);
      setIsSaveMenuOpen(false);
    }
  }

  async function fetchQueueOnce() {
    try {
      if (!refAdeme) return;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const simulName = simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
      const urlQueue = new URL("/backoffice/get_redis_detail", base);
      urlQueue.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlQueue.searchParams.set("log", `${simulName}_o3cl_queue`);
      const urlDone = new URL("/backoffice/get_redis_detail", base);
      urlDone.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlDone.searchParams.set("log", `${simulName}_o3cl_done_queue`);

      const [qres, dres] = await Promise.all([
        authorizedFetch(urlQueue.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
        authorizedFetch(urlDone.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
      ]);

      const parseItems = async (res: Response): Promise<any[]> => {
        if (!res.ok) return [];
        const data: any = await res.json().catch(() => null);
        if (Array.isArray(data?.items)) return data.items as any[];
        if (Array.isArray(data)) return data as any[];
        if (data && typeof data === "object" && Array.isArray((data as any).queue)) return (data as any).queue as any[];
        return [];
      };

      const [queueList, doneListRaw] = await Promise.all([parseItems(qres), parseItems(dres)]);
      const doneList = (doneListRaw || []).map((it: any) => ({ ...it, status: 1 }));
      const merged = [...doneList, ...queueList];
      setQueueItems(merged);
      setQueueSegments(merged.length || 0);
    } catch {}
  }

  function startQueuePolling() {
    try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    void fetchQueueOnce();
    const raw = (import.meta as any)?.env?.VITE_POLL_QUEUE_DELAY;
    const n = Number(raw);
    const delayMs = Number.isFinite(n) && n > 0 ? n : 30000;
    const id = window.setInterval(fetchQueueOnce, delayMs);
    queuePollIdRef.current = id;
  }

  useEffect(() => {
    return () => {
      try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    };
  }, []);

  useEffect(() => {
    if (!queueItems.length) return;
    const id = window.setInterval(() => setQueueNowTick((t) => t + 1), 1000);
    return () => { try { window.clearInterval(id); } catch {} };
  }, [queueItems.length]);

  async function handleSubmit() {
    try {
      const parsed = jsonText.trim() ? JSON.parse(jsonText) : {};
      const baseQuery = {
        api_debug: Boolean(apiDebug),
        skip,
        limit,
        ref_ademe: refAdeme,
      } as Record<string, unknown>;
      const query = { ...baseQuery, runs: parsed } as Record<string, unknown>;
      const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
      const body = {
        redis_db: 1,
        task: "tasks.ext_o3cl_managing.direct_scenarios",
        args: {
          ref_ademe: refAdeme,
          query,
        },
      };
      setSubmitting(true);
      // Use plain fetch to avoid adding Authorization header
      const res = await fetch(lambdaUrl, {
        method: "POST",
        headers: {
          Accept: "application/json, text/plain, */*",
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success("Submitted simulation");
      if (refAdeme) {
        const logName = `${(simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl")}_report_o3cl`;
        startPollingForResults(refAdeme, logName);
      }
      // If nb chunks > 1, also call append_scenarios
      if (Number(numChunks || 1) > 1) {
        const appendBody = {
          redis_db: 1,
          task: "tasks.ext_o3cl_managing.init_scenarios",
          args: {
            run_name: simulLog || "dev_report_o3cl",
            ref_ademe: refAdeme,
            nb_chunks: Number(numChunks || 1),
            nb_workers: Number(numWorkers || 1),
            nb_combination: 100,
            query,
          },
        } as Record<string, unknown>;
        try {
          const res2 = await fetch(lambdaUrl, {
            method: "POST",
            headers: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": "application/json",
            },
            body: JSON.stringify(appendBody),
          });
          if (!res2.ok) {
            const txt2 = await res2.text().catch(() => "");
            throw new Error(`HTTP ${res2.status} ${txt2}`);
          }
          message.success(`appending scenarios across ${Number(numChunks)} chunks`);
          // eslint-disable-next-line no-console
          console.debug("append_scenarios payload", appendBody);

          // Start queue polling for segmented progress
          startQueuePolling();
        } catch (e) {
          message.error("Failed to append scenarios");
        }
      }
      // eslint-disable-next-line no-console
      console.log("simulation payload", body);
    } catch (err) {
      message.error("Invalid JSON");
    } finally {
      setSubmitting(false);
    }
  }

  function handleConfirmWorkers() {
    const value = Number(numWorkers || 0);
    if (value > 10) {
      setWorkersError("Max 10 workers");
      setConfirmedWorkers(undefined);
      return;
    }
    if (value < 1) {
      setWorkersError("Min 1 worker");
      setConfirmedWorkers(undefined);
      return;
    }
    setWorkersError(undefined);
    setConfirmedWorkers(value);

    // Call scaling lambda
    const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
    const body = {
      redis_db: 1,
      task: "tasks.r_ecs_scaling.scale",
      args: {
        cluster: "checkdpe-dev-cluster",
        service: "checkdpe-cd-3cl-dev-service",
        desired: value,
      },
    };
    // eslint-disable-next-line no-console
    console.debug("[simulation] scaling workers", body);
    fetch(lambdaUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json, text/plain, */*" },
      body: JSON.stringify(body),
    })
      .then(async (res) => {
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} ${txt}`);
        }
        message.success(`updated workers to ${value}`);
      })
      .catch(() => {
        message.error("failed to update workers");
      });
  }

  return (
    <div style={{ minHeight: "100vh", background: "#ffffff", color: "#0b0c0f" }}>
      <TopMenu
        authLabel={userEmail || "login / sign-up"}
        authHref={(() => {
          const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
          if (configured) {
            try {
              const configuredUrl = new URL(configured);
              const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
              const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
              if (isConfiguredLocal && !isPageLocal) {
                // ignore local auth URL on non-localhost pages
              } else {
                // On non-local hosts, prefer explicit index.html so returnTo is added to the file URL
                if (!isConfiguredLocal) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  if (!endsWithHtml) {
                    const base = hasTrailingSlash ? configured.replace(/\/$/, "") : configured;
                    return base + "/index.html";
                  }
                }
                return configured;
              }
            } catch {
              return configured;
            }
          }
          if (window.location.hostname === "localhost") return "http://localhost:5173";
          return "/auth/index.html";
        })()}
        isAuthenticated={Boolean(userEmail)}
        centeredTitle={refAdeme}
        logoutHref={(() => {
          const domain = (import.meta.env.VITE_COGNITO_DOMAIN_URL as string | undefined)?.replace(/^https?:\/\//, "");
          if (!domain) return undefined;
          const clientId = import.meta.env.VITE_COGNITO_CLIENT_ID as string | undefined;
          const logoutRedirect = (import.meta.env.VITE_LOGOUT_REDIRECT_URL as string | undefined) || window.location.origin;
          if (!clientId) return undefined;
          return `https://${domain}/logout?client_id=${encodeURIComponent(clientId)}&logout_uri=${encodeURIComponent(logoutRedirect)}`;
        })()}
      />
      {/* Invisible iframe to pull session from auth origin when on different ports */}
      {!bridgeReady && (
        <iframe
          src={(() => {
            const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
            if (configured) {
              try {
                const configuredUrl = new URL(configured);
                const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
                const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
                if (!(isConfiguredLocal && !isPageLocal)) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  const base = endsWithHtml ? configured : (hasTrailingSlash ? configured.replace(/\/$/, "") + "/index.html" : configured + "/index.html");
                  return base;
                }
              } catch {
                return configured.replace(/\/$/, "") + "/index.html";
              }
            }
            if (window.location.hostname === "localhost") return "http://localhost:5173/index.html";
            return "/auth/index.html";
          })()}
          style={{ display: "none" }}
          title="session-bridge"
        />
      )}
      <div style={{ padding: 24 }}>
      <div style={{ display: "flex", alignItems: "flex-start", gap: 16 }}>
        {isEditorOpen ? (
          <DpeDrawerEditor
            inline
            open={isEditorOpen}
            onClose={() => setIsEditorOpen(false)}
            width={480}
            rootJsonText={jsonText}
            onApply={(next) => { hasUserEditedRef.current = true; flushSync(() => setJsonText(next)); }}
            apiLoadParams={refAdeme ? { baseUrl: (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr", ref_ademe: refAdeme } : undefined}
            getAccessToken={getAccessToken}
            onLoadedFromApi={(data) => {
              try {
                const text = JSON.stringify(data, null, 2);
                setJsonText((prev) => (prev?.trim() ? prev : text));
              } catch {}
            }}
            onHighlightJsonPath={({ collection, itemKey, indices }) => {
              try {
                const ta = textAreaRef.current;
                if (!ta) return;
                const text = ta.value;
                const variantPath = `dpe.logement.enveloppe.${collection}.${itemKey}`;
                let searchFrom = 0;
                let scopeArrayStart = -1;
                let scopeArrayEnd = -1;
                while (true) {
                  const varIdx = text.indexOf('"elements_variant"', searchFrom);
                  if (varIdx === -1) break;
                  const quoteIdx = text.indexOf('"', varIdx + 18);
                  const quoteEnd = quoteIdx !== -1 ? text.indexOf('"', quoteIdx + 1) : -1;
                  const value = quoteIdx !== -1 && quoteEnd !== -1 ? text.slice(quoteIdx + 1, quoteEnd) : '';
                  if (value === variantPath) {
                    const scopeKeyIdx = text.indexOf('"elements_scope"', varIdx);
                    if (scopeKeyIdx !== -1) {
                      const openBracket = text.indexOf('[', scopeKeyIdx);
                      if (openBracket !== -1) {
                        scopeArrayStart = openBracket;
                        const closeBracket = text.indexOf(']', openBracket);
                        if (closeBracket !== -1) scopeArrayEnd = closeBracket + 1;
                      }
                    }
                    break;
                  }
                  searchFrom = varIdx + 1;
                }
                if (scopeArrayStart === -1 || scopeArrayEnd === -1) return;
                const prevSelStart = ta.selectionStart;
                const prevSelEnd = ta.selectionEnd;
                const prevScrollTop = ta.scrollTop;
                const prevScrollLeft = ta.scrollLeft;
                try { (ta as any).focus({ preventScroll: true }); } catch { try { ta.focus(); } catch {} }
                try { ta.setSelectionRange(scopeArrayStart, scopeArrayEnd); } catch {}
                try { ta.scrollTop = prevScrollTop; ta.scrollLeft = prevScrollLeft; } catch {}
                window.setTimeout(() => {
                  try {
                    (ta as any).focus({ preventScroll: true });
                    ta.setSelectionRange(prevSelStart, prevSelEnd);
                    ta.scrollTop = prevScrollTop;
                    ta.scrollLeft = prevScrollLeft;
                  } catch {}
                }, 600);
              } catch {}
            }}
          />
        ) : null}

        <div style={{ flex: 1 }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12 }}>
            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
              <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Simulation</Title>
              <Button type="primary" size="large" icon={<LeftOutlined />} onClick={openEditor} disabled={isEditorOpen}>Edit</Button>
            </div>
            <Button onClick={() => setIsChainlitOpen(true)}>build with AI</Button>
          </div>
          <Paragraph style={{ color: "#4b5563", marginTop: 4 }}>Provide JSON and configure options, then submit.</Paragraph>
          
          <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
            <div style={{ display: "grid" }}>
              <textarea
                ref={textAreaRef}
                value={jsonText}
                onChange={(e) => { hasUserEditedRef.current = true; setJsonText(e.target.value); }}
                placeholder="Paste or write JSON here"
                style={{
                  minHeight: 420,
                  width: "100%",
                  background: isEditorOpen ? "#f3f4f6" : "#ffffff",
                  color: isEditorOpen ? "#6b7280" : "#111827",
                  border: "1px solid #e5e7eb",
                  borderRadius: 8,
                  padding: 12,
                  fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace",
                  fontSize: 14,
                  lineHeight: 1.45,
                  resize: "vertical",
                  cursor: isEditorOpen ? "default" : "text",
                  overflow: "auto",
                }}
                readOnly={isEditorOpen}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <Collapse
                destroyOnHidden
                items={[
                  {
                    key: "options",
                    label: "Options",
                    children: (
                      <Space direction="vertical" size={12} style={{ width: "100%" }}>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>api_debug</div>
                          <Select
                            value={apiDebug as number | undefined}
                            onChange={(v) => setApiDebug(v)}
                            allowClear
                            placeholder="none"
                            options={apiDebugOptions}
                            style={{ width: "100%" }}
                          />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>skip</div>
                          <InputNumber value={skip} onChange={(v) => setSkip(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>limit</div>
                          <InputNumber value={limit} onChange={(v) => setLimit(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb chunks</div>
                          <InputNumber value={numChunks} onChange={(v) => setNumChunks(Number(v ?? 1))} style={{ width: "100%" }} min={1} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb workers</div>
                          <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                            <InputNumber value={numWorkers} onChange={(v) => { setWorkersError(undefined); setNumWorkers(Number(v ?? 1)); }} style={{ width: 140 }} min={1} />
                            <Button size="small" onClick={handleConfirmWorkers}>ok</Button>
                            {typeof confirmedWorkers === "number" && (
                              <span style={{ color: "#059669", fontSize: 12 }}>saved: {confirmedWorkers}</span>
                            )}
                          </div>
                          {workersError && (
                            <div style={{ marginTop: 4, color: "#ef4444", fontSize: 12 }}>{workersError}</div>
                          )}
                        </div>
                      </Space>
                    ),
                  },
                ]}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <div style={{ display: "flex", gap: 8, justifyContent: "flex-end", alignItems: "center" }}>
                <Tooltip title={isSubmitBlocked ? "confirm simulation with OK (left panel), first." : undefined}>
                  <span style={{ display: "inline-block" }}>
                    <Button type="primary" onClick={handleSubmit} loading={submitting} disabled={isSubmitBlocked}>submit</Button>
                  </span>
                </Tooltip>
                <div style={{ position: "relative" }}>
                  <Button onClick={() => setIsSaveMenuOpen((v) => !v)}>...</Button>
                  {isSaveMenuOpen && (
                    <div style={{ position: "absolute", right: 0, top: "100%", background: "#fff", border: "1px solid #e5e7eb", borderRadius: 8, padding: 8, width: 260, boxShadow: "0 4px 14px rgba(0,0,0,0.08)", zIndex: 10 }}>
                    <div style={{ padding: "6px 8px", cursor: "pointer", borderRadius: 6 }} onClick={() => { setIsLoadSavedOpen(true); setIsSaveMenuOpen(false); }}>load scenario</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={() => { if (!isSaving) handleSaveToBackoffice(); }}>save {simulLog || "default"}</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={async () => {
                      if (isSaving) return;
                      const cdEnv = ((import.meta as any)?.env?.VITE_CD_ENV as string | undefined) || (import.meta.env.MODE === "development" ? "dev" : "prod");
                      const suggested = `${cdEnv}_simul_${simulLog || "test0001"}`;
                      const name = window.prompt(
                        "Save as name (format: <CD_ENV>_simul_<name>, e.g., dev_simul_test0001):",
                        suggested
                      );
                      if (!name) { setIsSaveMenuOpen(false); return; }
                      try {
                        const ref = `${refAdeme || "unknown"}-${name}`;
                        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
                        const apiUrl = new URL("/backoffice/redis_file_manage", base);
                        setIsSaving(true);
                        // eslint-disable-next-line no-console
                        console.debug("[simulation] POST redis_file_manage (save as)", { url: apiUrl.toString(), ref });
                        const res = await authorizedFetch(apiUrl.toString(), {
                          method: "POST",
                          headers: {
                            "Content-Type": "application/json",
                            Accept: "application/json, text/plain, */*",
                            "x-authorization": "dperdition",
                          },
                          body: JSON.stringify({ ref, text: jsonText }),
                        });
                        if (!res.ok) {
                          const txt = await res.text().catch(() => "");
                          throw new Error(`HTTP ${res.status} ${txt}`);
                        }
                        message.success(`saved ${name}`);
                        if (refAdeme) {
                          const { origin, pathname } = window.location;
                          const basePath = (() => {
                            try {
                              const idx = pathname.lastIndexOf("/");
                              return idx !== -1 ? pathname.slice(0, idx + 1) : "/";
                            } catch {
                              return "/";
                            }
                          })();
                          const targetUrl = `${origin}${basePath}index.html?ref_ademe=${encodeURIComponent(refAdeme)}&simul=${encodeURIComponent(name)}`;
                          window.location.href = targetUrl;
                        }
                      } catch {
                        message.error("save failed");
                      } finally {
                        setIsSaving(false);
                        setIsSaveMenuOpen(false);
                      }
                    }}>save as…</div>
                    </div>
                  )}
                </div>
              </div>
              <div style={{ marginTop: 8, display: "flex", justifyContent: "flex-end", minHeight: 24 }}>
                {!resultsUrl && isPolling && (
                  <Spin size="small" />
                )}
                {resultsUrl && (
                  <a href={resultsUrl} target="_blank" rel="noopener noreferrer" style={{ display: "inline-flex", alignItems: "center", gap: 6 }}>
                    Open simulation results <ExportOutlined />
                  </a>
                )}
              </div>
              {queueSegments > 0 && (
                <div style={{ marginTop: 12 }}>
                  <div style={{ height: 10, background: "#e5e7eb", borderRadius: 8, overflow: "hidden", display: "flex" }}>
                    {(queueItems.length ? queueItems : Array.from({ length: queueSegments })).map((item: any, idx: number) => {
                      const ts = item?.ts_started;
                      let startedAtMs = 0;
                      try {
                        if (typeof ts === "number") startedAtMs = ts > 1e12 ? ts : ts * 1000;
                        else if (typeof ts === "string") {
                          const n = Number(ts);
                          if (Number.isFinite(n)) startedAtMs = n > 1e12 ? n : n * 1000; else {
                            const t = Date.parse(ts);
                            if (!Number.isNaN(t)) startedAtMs = t;
                          }
                        }
                      } catch {}
                      const elapsedSec = Math.max(0, (Date.now() - startedAtMs) / 1000);
                      const statusNum = Number(item?.status ?? 0);
                      const pct = statusNum === 1 ? 100 : Math.max(0, Math.min(100, (elapsedSec / 60) * 100));
                      const fillColor = statusNum === 1 ? "#93c5fd" : "transparent";
                      return (
                        <div key={idx} style={{ flex: 1, display: "flex" }}>
                          <div style={{ width: `${pct}%`, background: fillColor, transition: "width 1s linear" }} />
                          {idx < queueSegments - 1 ? (
                            <div style={{ width: 2, background: "#ffffff" }} />
                          ) : null}
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              {/* editor inline panel is rendered on the right */}
            </div>
            <SimulationScenariosModal
              open={isScenariosOpen}
              onCancel={() => setIsScenariosOpen(false)}
              onLoad={(runs) => {
                try {
                  setJsonText(JSON.stringify(runs, null, 2));
                } catch {
                  // fallback to empty array
                  setJsonText(JSON.stringify([], null, 2));
                }
                setIsScenariosOpen(false);
              }}
            />
            <LoadScenarioModal
              open={isLoadSavedOpen}
              onCancel={() => setIsLoadSavedOpen(false)}
              onSelect={(payload: unknown) => {
                try {
                  // Accept payload either as normalized object { ref_ademe, label } or string "ref:label"
                  let ref: string | undefined;
                  let simul: string | undefined;
                  if (typeof payload === "string") {
                    const colon = payload.indexOf(":");
                    ref = colon !== -1 ? payload.slice(0, colon) : undefined;
                    simul = colon !== -1 ? payload.slice(colon + 1) : undefined;
                  } else if (payload && typeof payload === "object") {
                    ref = (payload as any).ref_ademe as string | undefined;
                    simul = (payload as any).label as string | undefined;
                  }
                  const url = new URL(window.location.href);
                  if (ref) url.searchParams.set("ref_ademe", ref);
                  if (simul) url.searchParams.set("simul", simul);
                  window.location.href = url.toString();
                } catch {}
                setIsLoadSavedOpen(false);
              }}
              baseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
              initialRefAdeme={refAdeme}
              getAccessToken={getAccessToken}
            />
          </Card>
        </div>

        {(() => {
          const chainlitUrl = (() => {
            const configured = import.meta.env.VITE_CHAINLIT_URL as string | undefined;
            if (configured && typeof configured === "string" && configured.trim()) return configured.trim();
            return "https://chainlit-stg.etiquettedpe.fr/chainlit";
          })();
          return (
            <ChainlitChatDrawer
              open={isChainlitOpen}
              onClose={() => setIsChainlitOpen(false)}
              title="Assistant"
              serverUrl={chainlitUrl}
              userEnv={{
                mail: "germain.blanchet@gmail.com",
                button_id: "contactez_nous",
                ref_ademe: refAdeme || "2508E0243162W",
              }}
            />
          );
        })()}

      </div>
      </div>
    </div>
  );
};



```

```typescriptreact
import React, { useEffect, useMemo, useRef, useState } from "react";
import "./amplify";
import { authorizedFetch, waitForAccessToken, getAccessToken, setBridgeAccessToken } from "./auth";
import { Hub } from "aws-amplify/utils";
import { Button, Card, Col, Flex, Input, InputNumber, Row, Select, Space, Typography, message, Spin, Collapse, Tooltip } from "antd";
import { ExportOutlined, LeftOutlined } from "@ant-design/icons";
import { SimulationScenariosModal } from "@acme/simulation-scenarios";
import { LoadScenarioModal } from "@acme/load-scenario";
import { DpeDrawerEditor, fetchSimulationTemplateJson } from "@acme/dpe-editor";
import { SimulationResults } from "@acme/simulation-results";
import { ChainlitChatDrawer } from "@acme/chainlit-client";
import { TopMenu } from "@acme/top-menu";
import { fetchAuthSession, getCurrentUser, fetchUserAttributes } from "aws-amplify/auth";
import { flushSync } from "react-dom";

const { Title, Paragraph } = Typography;

export const App: React.FC = () => {
  const [jsonText, setJsonText] = useState<string>("{\n  \"items\": []\n}");
  const textAreaRef = useRef<HTMLTextAreaElement | null>(null);
  const [apiDebug, setApiDebug] = useState<number | undefined>(undefined);
  const [skip, setSkip] = useState<number>(1);
  const [limit, setLimit] = useState<number>(10);
  const [numChunks, setNumChunks] = useState<number>(1);
  useEffect(() => { setNumChunks(2); }, []);
  const [numWorkers, setNumWorkers] = useState<number>(1);
  const [confirmedWorkers, setConfirmedWorkers] = useState<number | undefined>(undefined);
  const [workersError, setWorkersError] = useState<string | undefined>(undefined);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [userEmail, setUserEmail] = useState<string | undefined>(undefined);
  const [bridgeReady, setBridgeReady] = useState<boolean>(false);
  const [bridgeAuthenticated, setBridgeAuthenticated] = useState<boolean>(false);
  const hasInitFetchedRef = useRef<boolean>(false);
  const hasUserEditedRef = useRef<boolean>(false);
  const [refAdeme, setRefAdeme] = useState<string | undefined>(undefined);
  const [simulLog, setSimulLog] = useState<string | undefined>(undefined);
  const [isSaveMenuOpen, setIsSaveMenuOpen] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [resultsUrl, setResultsUrl] = useState<string | undefined>(undefined);
  const activePollAbortRef = useRef<{ cancel: () => void } | null>(null);
  const [isPolling, setIsPolling] = useState<boolean>(false);
  const [isScenariosOpen, setIsScenariosOpen] = useState<boolean>(false);
  const [isLoadSavedOpen, setIsLoadSavedOpen] = useState<boolean>(false);
  const [isEditorOpen, setIsEditorOpen] = useState<boolean>(false);
  const [isChainlitOpen, setIsChainlitOpen] = useState<boolean>(false);
  const [queueSegments, setQueueSegments] = useState<number>(0);
  const [queueItems, setQueueItems] = useState<any[]>([]);
  const queuePollIdRef = useRef<number | null>(null);
  const [queueNowTick, setQueueNowTick] = useState<number>(0);
  function openEditor() { setIsEditorOpen(true); }
  const hasLoadedTemplateRef = useRef<boolean>(false);
  const editorOriginalTextRef = useRef<string>("");

  useEffect(() => {
    let isCancelled = false;
    // Listen to session bridge messages from auth app
    function onMessage(ev: MessageEvent) {
      try {
        const payload = ev.data;
        if (!payload || payload.type !== "cognito-session-bridge") return;
        const authOrigin = payload?.data?.authOrigin as string | undefined;
        // Optionally validate origin
        if (authOrigin && !ev.origin.startsWith(authOrigin)) {
          // origin mismatch – ignore
          return;
        }
        setBridgeReady(true);
        const isAuthenticated = Boolean(payload?.data?.isAuthenticated);
        const tokenFromBridge = (payload?.data?.accessToken as string | undefined) || undefined;
        if (tokenFromBridge) setBridgeAccessToken(tokenFromBridge);
        if (isAuthenticated) setBridgeAuthenticated(true);
        const emailFromBridge = (payload?.data?.email as string | undefined) || (payload?.data?.username as string | undefined);
        if (!isCancelled && emailFromBridge) {
          setUserEmail((prev) => prev || emailFromBridge);
        }
      } catch {}
    }
    window.addEventListener("message", onMessage);
    
    (async () => {
      try {
        const url = new URL(window.location.href);
        const ra = url.searchParams.get("ref_ademe") || undefined;
        const sim = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string | undefined) || undefined;
        if (!isCancelled) {
          setRefAdeme(ra);
          setSimulLog(sim);
        }
      } catch {}
      // Immediate cookie-based fallback for username/email
      try {
        const parts = document.cookie.split("; ").filter(Boolean);
        for (const part of parts) {
          const idx = part.indexOf("=");
          if (idx === -1) continue;
          const key = part.substring(0, idx);
          const val = part.substring(idx + 1);
          if (key.startsWith("CognitoIdentityServiceProvider.") && key.endsWith(".LastAuthUser")) {
            const raw = decodeURIComponent(val);
            if (raw && !isCancelled) {
              setUserEmail(raw);
              return; // found username from cookie; stop here
            }
          }
        }
      } catch {}

      // Fallback #2: decode idToken cookie to extract email claim
      try {
        const all = document.cookie.split("; ").filter(Boolean);
        const prefix = "CognitoIdentityServiceProvider.";
        for (const cookie of all) {
          const eq = cookie.indexOf("=");
          if (eq === -1) continue;
          const name = cookie.substring(0, eq);
          if (!name.startsWith(prefix) || !name.endsWith(".idToken")) continue;
          const raw = decodeURIComponent(cookie.substring(eq + 1));
          const parts = raw.split(".");
          if (parts.length >= 2) {
            const mid = parts[1]!;
            const payload = JSON.parse(atob(mid.replace(/-/g, "+").replace(/_/g, "/")));
            const emailClaim = (payload && (payload.email || payload.username)) as string | undefined;
            if (emailClaim && !isCancelled) {
              setUserEmail(emailClaim);
              break;
            }
          }
        }
      } catch {}

      try {
        // Prefer Cognito username (often the email) if available
        const { username } = await getCurrentUser();
        if (username && !isCancelled) {
          setUserEmail(username || undefined);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      // Try fetching user attributes (email) when available
      try {
        const attrs = await fetchUserAttributes();
        const emailAttr = attrs?.email as string | undefined;
        if (emailAttr && !isCancelled) {
          setUserEmail(emailAttr);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      try {
        const session = await fetchAuthSession();
        const emailClaim = (session as any)?.tokens?.idToken?.payload?.email as string | undefined;
        if (!isCancelled) setUserEmail(emailClaim ?? undefined);
      } catch {
        if (!isCancelled) setUserEmail(undefined);
      }
    })();
    return () => {
      isCancelled = true;
      window.removeEventListener("message", onMessage);
    };
  }, []);

  // Also try firing when bridge reports authenticated (helps cross-port first load)
  useEffect(() => {
    if (!bridgeAuthenticated || hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    (async () => {
      try {
        const token = await waitForAccessToken(15000, 250);
        if (!token) return;
        if (hasInitFetchedRef.current) return;
        hasInitFetchedRef.current = true;
        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", refAdeme);
        apiUrl.searchParams.set("log", simul);
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail (bridge)", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail (bridge)", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed (bridge)", err);
      }
    })();
    return () => controller.abort();
  }, [bridgeAuthenticated]);

  // On init: if URL contains simul=default, call template endpoint and initialize editor JSON
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        if (cancelled) return;
        if (hasLoadedTemplateRef.current) return;
        const url = new URL(window.location.href);
        const simul = url.searchParams.get("simul");
        if (simul !== "default") return;
        if (!refAdeme) return;
        if (hasUserEditedRef.current) return;

        const accessToken = await waitForAccessToken(15000, 250);
        if (!accessToken) return;

        const baseUrl = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const template = await fetchSimulationTemplateJson<any>({ baseUrl, ref_ademe: refAdeme, accessToken });
        if (cancelled) return;

        const sourceRuns: any[] = Array.isArray(template)
          ? template
          : (template && Array.isArray(template.runs) ? template.runs : []);

        const transformedRuns = sourceRuns.map((run) => {
          const forced = run?.parameters?.input_forced || {};
          const scenarios = Array.isArray(run?.scenarios) ? run.scenarios : [];
          const nextScenarios = scenarios.map((sc: any) => {
            const baseInput = (sc && sc.input && typeof sc.input === "object") ? sc.input : {};
            const mergedInput = { ...forced, ...baseInput };
            return { ...sc, input: mergedInput };
          });
          const { parameters, ...rest } = run || {};
          return { ...rest, scenarios: nextScenarios };
        });

        if (transformedRuns.length > 0) {
          hasLoadedTemplateRef.current = true;
          setJsonText(JSON.stringify(transformedRuns, null, 2));
        }
      } catch {
        // ignore
      }
    };

    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // On init: if URL contains ?ref_ademe=..., call backoffice endpoint (Bearer included when available)
  useEffect(() => {
    if (hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const apiUrl = new URL("/backoffice/get_redis_detail", base);
    apiUrl.searchParams.set("ref_ademe", refAdeme);
    apiUrl.searchParams.set("log", simul);

    async function doFetchOnce() {
      if (hasInitFetchedRef.current) return;
      hasInitFetchedRef.current = true;
      try {
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    }

    (async () => {
      try {
        // Wait for a valid access token before calling the endpoint
        const token = await waitForAccessToken(15000, 250);
        if (!token) {
          // eslint-disable-next-line no-console
          console.warn("[simulation] skipping get_redis_detail: no Cognito token available");
          return; // we'll rely on auth Hub events below if sign-in happens later
        }
        await doFetchOnce();
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    })();

    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh"){ doFetchOnce(); }
      } catch {}
    });

    // Poll as a safety net in case Hub events fired before subscribe
    const pollId = window.setInterval(async () => {
      try {
        if (hasInitFetchedRef.current) { window.clearInterval(pollId); return; }
        const token = await getAccessToken();
        if (token) {
          window.clearInterval(pollId);
          await doFetchOnce();
        }
      } catch {}
    }, 500);

    return () => {
      try { (removeHub as any)?.(); } catch {}
      try { window.clearInterval(pollId); } catch {}
      controller.abort();
    };
  }, []);

  // When only ref_ademe is present and no simul param, initialize editor to [] and open load modal (after token available)
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        const url = new URL(window.location.href);
        const hasRef = Boolean(url.searchParams.get("ref_ademe"));
        const hasSimul = url.searchParams.has("simul");
        if (hasRef && !hasSimul) {
          if (!hasUserEditedRef.current) setJsonText("[]");
          const token = await waitForAccessToken(15000, 250);
          if (cancelled) return;
          if (token) setIsLoadSavedOpen(true);
        }
      } catch {}
    };
    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // When opening with both ref_ademe and simul, expand the editor drawer by default
  useEffect(() => {
    try {
      const url = new URL(window.location.href);
      const hasRef = Boolean(url.searchParams.get("ref_ademe"));
      const simul = url.searchParams.get("simul");
      if (hasRef && simul && simul !== "default") {
        setIsEditorOpen(true);
      }
    } catch {}
  }, [refAdeme, simulLog]);

  const apiDebugOptions = useMemo(() => [
    { label: "none", value: undefined },
    { label: "1", value: 1 },
    { label: "2", value: 2 },
  ], []);

  useEffect(() => {
    return () => {
      try { activePollAbortRef.current?.cancel(); setIsPolling(false); } catch {}
    };
  }, []);

  // Capture the JSON snapshot when opening the editor to detect unconfirmed changes
  useEffect(() => {
    try {
      if (isEditorOpen) {
        editorOriginalTextRef.current = jsonText || "";
      }
    } catch {}
  }, [isEditorOpen]);

  const isEditorDirty = useMemo(() => {
    if (!isEditorOpen) return false;
    try {
      const a = (editorOriginalTextRef.current || "").trim();
      const b = (jsonText || "").trim();
      if (!a && !b) return false;
      try {
        const ap = a ? JSON.parse(a) : null;
        const bp = b ? JSON.parse(b) : null;
        return JSON.stringify(ap) !== JSON.stringify(bp);
      } catch {
        return a !== b;
      }
    } catch {
      return false;
    }
  }, [isEditorOpen, jsonText]);

  const isSubmitBlocked = isEditorOpen && isEditorDirty;

  function startPollingForResults(ref: string, log: string) {
    // cancel any previous polling
    try { activePollAbortRef.current?.cancel(); } catch {}
    let cancelled = false;
    activePollAbortRef.current = { cancel: () => { cancelled = true; setIsPolling(false); } };

    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const resultsHref = `https://bo.scandpe.fr/simulation/index.html?tab=results&dpe=${encodeURIComponent(ref)}`;

    setIsPolling(true);
    const tick = async () => {
      if (cancelled) return;
      try {
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", ref);
        apiUrl.searchParams.set("log", log);
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
        });
        if (res.ok) {
          const data = await res.json().catch(() => null);
          if (data && data.status === "processed") {
            setResultsUrl(resultsHref);
            cancelled = true;
            setIsPolling(false);
            return;
          }
        }
      } catch {}
      if (!cancelled) {
        window.setTimeout(tick, 1000);
      }
    };
    tick();
  }

  async function handleSaveToBackoffice() {
    try {
      if (!refAdeme || !simulLog) {
        message.error("Missing ref_ademe or simul");
        setIsSaveMenuOpen(false);
        return;
      }
      const ref = `${refAdeme}-${simulLog}`;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const apiUrl = new URL("/backoffice/redis_file_manage", base);
      setIsSaving(true);
      // eslint-disable-next-line no-console
      console.debug("[simulation] POST redis_file_manage", { url: apiUrl.toString(), ref });
      const res = await authorizedFetch(apiUrl.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json, text/plain, */*",
          "x-authorization": "dperdition",
        },
        body: JSON.stringify({ ref, text: jsonText }),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success(`saved ${simulLog}`);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error("redis_file_manage failed", err);
      message.error("save failed");
    } finally {
      setIsSaving(false);
      setIsSaveMenuOpen(false);
    }
  }

  async function fetchQueueOnce() {
    try {
      if (!refAdeme) return;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const simulName = simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
      const urlQueue = new URL("/backoffice/get_redis_detail", base);
      urlQueue.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlQueue.searchParams.set("log", `${simulName}_o3cl_queue`);
      const urlDone = new URL("/backoffice/get_redis_detail", base);
      urlDone.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlDone.searchParams.set("log", `${simulName}_o3cl_done_queue`);

      const [qres, dres] = await Promise.all([
        authorizedFetch(urlQueue.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
        authorizedFetch(urlDone.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
      ]);

      const parseItems = async (res: Response): Promise<any[]> => {
        if (!res.ok) return [];
        const data: any = await res.json().catch(() => null);
        if (Array.isArray(data?.items)) return data.items as any[];
        if (Array.isArray(data)) return data as any[];
        if (data && typeof data === "object" && Array.isArray((data as any).queue)) return (data as any).queue as any[];
        return [];
      };

      const [queueList, doneListRaw] = await Promise.all([parseItems(qres), parseItems(dres)]);
      const doneList = (doneListRaw || []).map((it: any) => ({ ...it, status: 1 }));
      const merged = [...doneList, ...queueList];
      setQueueItems(merged);
      setQueueSegments(merged.length || 0);
    } catch {}
  }

  function startQueuePolling() {
    try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    void fetchQueueOnce();
    const raw = (import.meta as any)?.env?.VITE_POLL_QUEUE_DELAY;
    const n = Number(raw);
    const delayMs = Number.isFinite(n) && n > 0 ? n : 30000;
    const id = window.setInterval(fetchQueueOnce, delayMs);
    queuePollIdRef.current = id;
  }

  useEffect(() => {
    return () => {
      try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    };
  }, []);

  useEffect(() => {
    if (!queueItems.length) return;
    const id = window.setInterval(() => setQueueNowTick((t) => t + 1), 1000);
    return () => { try { window.clearInterval(id); } catch {} };
  }, [queueItems.length]);

  async function handleSubmit() {
    try {
      const parsed = jsonText.trim() ? JSON.parse(jsonText) : {};
      const baseQuery = {
        api_debug: Boolean(apiDebug),
        skip,
        limit,
        ref_ademe: refAdeme,
      } as Record<string, unknown>;
      const query = { ...baseQuery, runs: parsed } as Record<string, unknown>;
      const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
      const body = {
        redis_db: 1,
        task: "tasks.ext_o3cl_managing.direct_scenarios",
        args: {
          ref_ademe: refAdeme,
          query,
        },
      };
      setSubmitting(true);
      // Use plain fetch to avoid adding Authorization header
      const res = await fetch(lambdaUrl, {
        method: "POST",
        headers: {
          Accept: "application/json, text/plain, */*",
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success("Submitted simulation");
      if (refAdeme) {
        const logName = `${(simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl")}_report_o3cl`;
        startPollingForResults(refAdeme, logName);
      }
      // If nb chunks > 1, also call append_scenarios
      if (Number(numChunks || 1) > 1) {
        const appendBody = {
          redis_db: 1,
          task: "tasks.ext_o3cl_managing.init_scenarios",
          args: {
            run_name: simulLog || "dev_report_o3cl",
            ref_ademe: refAdeme,
            nb_chunks: Number(numChunks || 1),
            nb_workers: Number(numWorkers || 1),
            nb_combination: 100,
            query,
          },
        } as Record<string, unknown>;
        try {
          const res2 = await fetch(lambdaUrl, {
            method: "POST",
            headers: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": "application/json",
            },
            body: JSON.stringify(appendBody),
          });
          if (!res2.ok) {
            const txt2 = await res2.text().catch(() => "");
            throw new Error(`HTTP ${res2.status} ${txt2}`);
          }
          message.success(`appending scenarios across ${Number(numChunks)} chunks`);
          // eslint-disable-next-line no-console
          console.debug("append_scenarios payload", appendBody);

          // Start queue polling for segmented progress
          startQueuePolling();
        } catch (e) {
          message.error("Failed to append scenarios");
        }
      }
      // eslint-disable-next-line no-console
      console.log("simulation payload", body);
    } catch (err) {
      message.error("Invalid JSON");
    } finally {
      setSubmitting(false);
    }
  }

  function handleConfirmWorkers() {
    const value = Number(numWorkers || 0);
    if (value > 10) {
      setWorkersError("Max 10 workers");
      setConfirmedWorkers(undefined);
      return;
    }
    if (value < 1) {
      setWorkersError("Min 1 worker");
      setConfirmedWorkers(undefined);
      return;
    }
    setWorkersError(undefined);
    setConfirmedWorkers(value);

    // Call scaling lambda
    const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
    const body = {
      redis_db: 1,
      task: "tasks.r_ecs_scaling.scale",
      args: {
        cluster: "checkdpe-dev-cluster",
        service: "checkdpe-cd-3cl-dev-service",
        desired: value,
      },
    };
    // eslint-disable-next-line no-console
    console.debug("[simulation] scaling workers", body);
    fetch(lambdaUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json, text/plain, */*" },
      body: JSON.stringify(body),
    })
      .then(async (res) => {
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} ${txt}`);
        }
        message.success(`updated workers to ${value}`);
      })
      .catch(() => {
        message.error("failed to update workers");
      });
  }

  return (
    <div style={{ minHeight: "100vh", background: "#ffffff", color: "#0b0c0f" }}>
      <TopMenu
        authLabel={userEmail || "login / sign-up"}
        authHref={(() => {
          const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
          if (configured) {
            try {
              const configuredUrl = new URL(configured);
              const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
              const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
              if (isConfiguredLocal && !isPageLocal) {
                // ignore local auth URL on non-localhost pages
              } else {
                // On non-local hosts, prefer explicit index.html so returnTo is added to the file URL
                if (!isConfiguredLocal) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  if (!endsWithHtml) {
                    const base = hasTrailingSlash ? configured.replace(/\/$/, "") : configured;
                    return base + "/index.html";
                  }
                }
                return configured;
              }
            } catch {
              return configured;
            }
          }
          if (window.location.hostname === "localhost") return "http://localhost:5173";
          return "/auth/index.html";
        })()}
        isAuthenticated={Boolean(userEmail)}
        centeredTitle={refAdeme}
        logoutHref={(() => {
          const domain = (import.meta.env.VITE_COGNITO_DOMAIN_URL as string | undefined)?.replace(/^https?:\/\//, "");
          if (!domain) return undefined;
          const clientId = import.meta.env.VITE_COGNITO_CLIENT_ID as string | undefined;
          const logoutRedirect = (import.meta.env.VITE_LOGOUT_REDIRECT_URL as string | undefined) || window.location.origin;
          if (!clientId) return undefined;
          return `https://${domain}/logout?client_id=${encodeURIComponent(clientId)}&logout_uri=${encodeURIComponent(logoutRedirect)}`;
        })()}
      />
      {/* Invisible iframe to pull session from auth origin when on different ports */}
      {!bridgeReady && (
        <iframe
          src={(() => {
            const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
            if (configured) {
              try {
                const configuredUrl = new URL(configured);
                const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
                const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
                if (!(isConfiguredLocal && !isPageLocal)) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  const base = endsWithHtml ? configured : (hasTrailingSlash ? configured.replace(/\/$/, "") + "/index.html" : configured + "/index.html");
                  return base;
                }
              } catch {
                return configured.replace(/\/$/, "") + "/index.html";
              }
            }
            if (window.location.hostname === "localhost") return "http://localhost:5173/index.html";
            return "/auth/index.html";
          })()}
          style={{ display: "none" }}
          title="session-bridge"
        />
      )}
      <div style={{ padding: 24 }}>
      <div style={{ display: "flex", alignItems: "flex-start", gap: 16 }}>
        {isEditorOpen ? (
          <DpeDrawerEditor
            inline
            open={isEditorOpen}
            onClose={() => setIsEditorOpen(false)}
            width={480}
            rootJsonText={jsonText}
            onApply={(next) => { hasUserEditedRef.current = true; flushSync(() => setJsonText(next)); }}
            apiLoadParams={refAdeme ? { baseUrl: (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr", ref_ademe: refAdeme } : undefined}
            getAccessToken={getAccessToken}
            onLoadedFromApi={(data) => {
              try {
                const text = JSON.stringify(data, null, 2);
                setJsonText((prev) => (prev?.trim() ? prev : text));
              } catch {}
            }}
            onHighlightJsonPath={({ collection, itemKey, indices }) => {
              try {
                const ta = textAreaRef.current;
                if (!ta) return;
                const text = ta.value;
                const variantPath = `dpe.logement.enveloppe.${collection}.${itemKey}`;
                let searchFrom = 0;
                let scopeArrayStart = -1;
                let scopeArrayEnd = -1;
                while (true) {
                  const varIdx = text.indexOf('"elements_variant"', searchFrom);
                  if (varIdx === -1) break;
                  const quoteIdx = text.indexOf('"', varIdx + 18);
                  const quoteEnd = quoteIdx !== -1 ? text.indexOf('"', quoteIdx + 1) : -1;
                  const value = quoteIdx !== -1 && quoteEnd !== -1 ? text.slice(quoteIdx + 1, quoteEnd) : '';
                  if (value === variantPath) {
                    const scopeKeyIdx = text.indexOf('"elements_scope"', varIdx);
                    if (scopeKeyIdx !== -1) {
                      const openBracket = text.indexOf('[', scopeKeyIdx);
                      if (openBracket !== -1) {
                        scopeArrayStart = openBracket;
                        const closeBracket = text.indexOf(']', openBracket);
                        if (closeBracket !== -1) scopeArrayEnd = closeBracket + 1;
                      }
                    }
                    break;
                  }
                  searchFrom = varIdx + 1;
                }
                if (scopeArrayStart === -1 || scopeArrayEnd === -1) return;
                const prevSelStart = ta.selectionStart;
                const prevSelEnd = ta.selectionEnd;
                const prevScrollTop = ta.scrollTop;
                const prevScrollLeft = ta.scrollLeft;
                try { (ta as any).focus({ preventScroll: true }); } catch { try { ta.focus(); } catch {} }
                try { ta.setSelectionRange(scopeArrayStart, scopeArrayEnd); } catch {}
                try { ta.scrollTop = prevScrollTop; ta.scrollLeft = prevScrollLeft; } catch {}
                window.setTimeout(() => {
                  try {
                    (ta as any).focus({ preventScroll: true });
                    ta.setSelectionRange(prevSelStart, prevSelEnd);
                    ta.scrollTop = prevScrollTop;
                    ta.scrollLeft = prevScrollLeft;
                  } catch {}
                }, 600);
              } catch {}
            }}
          />
        ) : null}

        <div style={{ flex: 1 }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12 }}>
            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
              <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Simulation</Title>
              <Button type="primary" size="large" icon={<LeftOutlined />} onClick={openEditor} disabled={isEditorOpen}>Edit</Button>
            </div>
            <Button onClick={() => setIsChainlitOpen(true)}>build with AI</Button>
          </div>
          <Paragraph style={{ color: "#4b5563", marginTop: 4 }}>Provide JSON and configure options, then submit.</Paragraph>
          
          <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
            <div style={{ display: "grid" }}>
              <textarea
                ref={textAreaRef}
                value={jsonText}
                onChange={(e) => { hasUserEditedRef.current = true; setJsonText(e.target.value); }}
                placeholder="Paste or write JSON here"
                style={{
                  minHeight: 420,
                  width: "100%",
                  background: isEditorOpen ? "#f3f4f6" : "#ffffff",
                  color: isEditorOpen ? "#6b7280" : "#111827",
                  border: "1px solid #e5e7eb",
                  borderRadius: 8,
                  padding: 12,
                  fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace",
                  fontSize: 14,
                  lineHeight: 1.45,
                  resize: "vertical",
                  cursor: isEditorOpen ? "default" : "text",
                  overflow: "auto",
                }}
                readOnly={isEditorOpen}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <Collapse
                destroyOnHidden
                items={[
                  {
                    key: "options",
                    label: "Options",
                    children: (
                      <Space direction="vertical" size={12} style={{ width: "100%" }}>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>api_debug</div>
                          <Select
                            value={apiDebug as number | undefined}
                            onChange={(v) => setApiDebug(v)}
                            allowClear
                            placeholder="none"
                            options={apiDebugOptions}
                            style={{ width: "100%" }}
                          />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>skip</div>
                          <InputNumber value={skip} onChange={(v) => setSkip(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>limit</div>
                          <InputNumber value={limit} onChange={(v) => setLimit(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb chunks</div>
                          <InputNumber value={numChunks} onChange={(v) => setNumChunks(Number(v ?? 1))} style={{ width: "100%" }} min={1} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb workers</div>
                          <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                            <InputNumber value={numWorkers} onChange={(v) => { setWorkersError(undefined); setNumWorkers(Number(v ?? 1)); }} style={{ width: 140 }} min={1} />
                            <Button size="small" onClick={handleConfirmWorkers}>ok</Button>
                            {typeof confirmedWorkers === "number" && (
                              <span style={{ color: "#059669", fontSize: 12 }}>saved: {confirmedWorkers}</span>
                            )}
                          </div>
                          {workersError && (
                            <div style={{ marginTop: 4, color: "#ef4444", fontSize: 12 }}>{workersError}</div>
                          )}
                        </div>
                      </Space>
                    ),
                  },
                ]}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <div style={{ display: "flex", gap: 8, justifyContent: "flex-end", alignItems: "center" }}>
                <Tooltip title={isSubmitBlocked ? "confirm simulation with OK (left panel), first." : undefined}>
                  <span style={{ display: "inline-block" }}>
                    <Button type="primary" onClick={handleSubmit} loading={submitting} disabled={isSubmitBlocked}>submit</Button>
                  </span>
                </Tooltip>
                <div style={{ position: "relative" }}>
                  <Button onClick={() => setIsSaveMenuOpen((v) => !v)}>...</Button>
                  {isSaveMenuOpen && (
                    <div style={{ position: "absolute", right: 0, top: "100%", background: "#fff", border: "1px solid #e5e7eb", borderRadius: 8, padding: 8, width: 260, boxShadow: "0 4px 14px rgba(0,0,0,0.08)", zIndex: 10 }}>
                    <div style={{ padding: "6px 8px", cursor: "pointer", borderRadius: 6 }} onClick={() => { setIsLoadSavedOpen(true); setIsSaveMenuOpen(false); }}>load scenario</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={() => { if (!isSaving) handleSaveToBackoffice(); }}>save {simulLog || "default"}</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={async () => {
                      if (isSaving) return;
                      const cdEnv = ((import.meta as any)?.env?.VITE_CD_ENV as string | undefined) || (import.meta.env.MODE === "development" ? "dev" : "prod");
                      const suggested = `${cdEnv}_simul_${simulLog || "test0001"}`;
                      const name = window.prompt(
                        "Save as name (format: <CD_ENV>_simul_<name>, e.g., dev_simul_test0001):",
                        suggested
                      );
                      if (!name) { setIsSaveMenuOpen(false); return; }
                      try {
                        const ref = `${refAdeme || "unknown"}-${name}`;
                        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
                        const apiUrl = new URL("/backoffice/redis_file_manage", base);
                        setIsSaving(true);
                        // eslint-disable-next-line no-console
                        console.debug("[simulation] POST redis_file_manage (save as)", { url: apiUrl.toString(), ref });
                        const res = await authorizedFetch(apiUrl.toString(), {
                          method: "POST",
                          headers: {
                            "Content-Type": "application/json",
                            Accept: "application/json, text/plain, */*",
                            "x-authorization": "dperdition",
                          },
                          body: JSON.stringify({ ref, text: jsonText }),
                        });
                        if (!res.ok) {
                          const txt = await res.text().catch(() => "");
                          throw new Error(`HTTP ${res.status} ${txt}`);
                        }
                        message.success(`saved ${name}`);
                        if (refAdeme) {
                          const { origin, pathname } = window.location;
                          const basePath = (() => {
                            try {
                              const idx = pathname.lastIndexOf("/");
                              return idx !== -1 ? pathname.slice(0, idx + 1) : "/";
                            } catch {
                              return "/";
                            }
                          })();
                          const targetUrl = `${origin}${basePath}index.html?ref_ademe=${encodeURIComponent(refAdeme)}&simul=${encodeURIComponent(name)}`;
                          window.location.href = targetUrl;
                        }
                      } catch {
                        message.error("save failed");
                      } finally {
                        setIsSaving(false);
                        setIsSaveMenuOpen(false);
                      }
                    }}>save as…</div>
                    </div>
                  )}
                </div>
              </div>
              <div style={{ marginTop: 8, display: "flex", justifyContent: "flex-end", minHeight: 24 }}>
                {!resultsUrl && isPolling && (
                  <Spin size="small" />
                )}
                {resultsUrl && (
                  <a href={resultsUrl} target="_blank" rel="noopener noreferrer" style={{ display: "inline-flex", alignItems: "center", gap: 6 }}>
                    Open simulation results <ExportOutlined />
                  </a>
                )}
              </div>
              {refAdeme ? (
                <div style={{ marginTop: 20 }}>
                  <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12, marginBottom: 12 }}>
                    <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Results preview</Title>
                  </div>
                  <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
                    <SimulationResults
                      dpeId={refAdeme}
                      getAccessToken={async () => (await getAccessToken()) || undefined}
                      apiBaseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
                      width={720}
                      height={300}
                    />
                  </Card>
                </div>
              ) : null}
              {queueSegments > 0 && (
                <div style={{ marginTop: 12 }}>
                  <div style={{ height: 10, background: "#e5e7eb", borderRadius: 8, overflow: "hidden", display: "flex" }}>
                    {(queueItems.length ? queueItems : Array.from({ length: queueSegments })).map((item: any, idx: number) => {
                      const ts = item?.ts_started;
                      let startedAtMs = 0;
                      try {
                        if (typeof ts === "number") startedAtMs = ts > 1e12 ? ts : ts * 1000;
                        else if (typeof ts === "string") {
                          const n = Number(ts);
                          if (Number.isFinite(n)) startedAtMs = n > 1e12 ? n : n * 1000; else {
                            const t = Date.parse(ts);
                            if (!Number.isNaN(t)) startedAtMs = t;
                          }
                        }
                      } catch {}
                      const elapsedSec = Math.max(0, (Date.now() - startedAtMs) / 1000);
                      const statusNum = Number(item?.status ?? 0);
                      const pct = statusNum === 1 ? 100 : Math.max(0, Math.min(100, (elapsedSec / 60) * 100));
                      const fillColor = statusNum === 1 ? "#93c5fd" : "transparent";
                      return (
                        <div key={idx} style={{ flex: 1, display: "flex" }}>
                          <div style={{ width: `${pct}%`, background: fillColor, transition: "width 1s linear" }} />
                          {idx < queueSegments - 1 ? (
                            <div style={{ width: 2, background: "#ffffff" }} />
                          ) : null}
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              {/* editor inline panel is rendered on the right */}
            </div>
            <SimulationScenariosModal
              open={isScenariosOpen}
              onCancel={() => setIsScenariosOpen(false)}
              onLoad={(runs) => {
                try {
                  setJsonText(JSON.stringify(runs, null, 2));
                } catch {
                  // fallback to empty array
                  setJsonText(JSON.stringify([], null, 2));
                }
                setIsScenariosOpen(false);
              }}
            />
            <LoadScenarioModal
              open={isLoadSavedOpen}
              onCancel={() => setIsLoadSavedOpen(false)}
              onSelect={(payload: unknown) => {
                try {
                  // Accept payload either as normalized object { ref_ademe, label } or string "ref:label"
                  let ref: string | undefined;
                  let simul: string | undefined;
                  if (typeof payload === "string") {
                    const colon = payload.indexOf(":");
                    ref = colon !== -1 ? payload.slice(0, colon) : undefined;
                    simul = colon !== -1 ? payload.slice(colon + 1) : undefined;
                  } else if (payload && typeof payload === "object") {
                    ref = (payload as any).ref_ademe as string | undefined;
                    simul = (payload as any).label as string | undefined;
                  }
                  const url = new URL(window.location.href);
                  if (ref) url.searchParams.set("ref_ademe", ref);
                  if (simul) url.searchParams.set("simul", simul);
                  window.location.href = url.toString();
                } catch {}
                setIsLoadSavedOpen(false);
              }}
              baseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
              initialRefAdeme={refAdeme}
              getAccessToken={getAccessToken}
            />
          </Card>
        </div>

        {(() => {
          const chainlitUrl = (() => {
            const configured = import.meta.env.VITE_CHAINLIT_URL as string | undefined;
            if (configured && typeof configured === "string" && configured.trim()) return configured.trim();
            return "https://chainlit-stg.etiquettedpe.fr/chainlit";
          })();
          return (
            <ChainlitChatDrawer
              open={isChainlitOpen}
              onClose={() => setIsChainlitOpen(false)}
              title="Assistant"
              serverUrl={chainlitUrl}
              userEnv={{
                mail: "germain.blanchet@gmail.com",
                button_id: "contactez_nous",
                ref_ademe: refAdeme || "2508E0243162W",
              }}
            />
          );
        })()}

      </div>
      </div>
    </div>
  );
};



```

Moved the results preview below the submit area and matched the header style to the main “Simulation” title (Title level 2).

Key edits in `apps/simul/src/App.tsx`:
- Removed the earlier preview under the title.
- Inserted the preview after the submit/actions section with:
```startLine:endLine:/Volumes/privateGg/ai-microfront-ant/apps/simul/src/App.tsx
1000:              </div>
1001:              {refAdeme ? (
1002:                <div style={{ marginTop: 20 }}>
1003:                  <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12, marginBottom: 12 }}>
1004:                    <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Results preview</Title>
1005:                  </div>
1006:                  <Card style={{ background: "#ffffff\", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
1007:                    <SimulationResults
1008:                      dpeId={refAdeme}
1009:                      getAccessToken={async () => (await getAccessToken()) || undefined}
1010:                      apiBaseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
1011:                      width={720}
1012:                      height={300}
1013:                    />
1014:                  </Card>
1015:                </div>
1016:              ) : null}
```

All lints pass.

```typescriptreact
1000:              </div>
1001:              {refAdeme ? (
1002:                <div style={{ marginTop: 20 }}>
1003:                  <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12, marginBottom: 12 }}>
1004:                    <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Results preview</Title>
1005:                  </div>
1006:                  <Card style={{ background: "#ffffff\", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
1007:                    <SimulationResults
1008:                      dpeId={refAdeme}
1009:                      getAccessToken={async () => (await getAccessToken()) || undefined}
1010:                      apiBaseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
1011:                      width={720}
1012:                      height={300}
1013:                    />
1014:                  </Card>
1015:                </div>
1016:              ) : null}
```

---

**User**

but the progress bar/loader should stay right under "submit"

---

**Cursor**

I'll move the loader alignment under the submit by changing the flex container under the submit button from justifyContent: "flex-end" to "flex-start". Then I'll run a lint check on the file.

```typescriptreact
import React, { useEffect, useMemo, useRef, useState } from "react";
import "./amplify";
import { authorizedFetch, waitForAccessToken, getAccessToken, setBridgeAccessToken } from "./auth";
import { Hub } from "aws-amplify/utils";
import { Button, Card, Col, Flex, Input, InputNumber, Row, Select, Space, Typography, message, Spin, Collapse, Tooltip } from "antd";
import { ExportOutlined, LeftOutlined } from "@ant-design/icons";
import { SimulationScenariosModal } from "@acme/simulation-scenarios";
import { LoadScenarioModal } from "@acme/load-scenario";
import { DpeDrawerEditor, fetchSimulationTemplateJson } from "@acme/dpe-editor";
import { SimulationResults } from "@acme/simulation-results";
import { ChainlitChatDrawer } from "@acme/chainlit-client";
import { TopMenu } from "@acme/top-menu";
import { fetchAuthSession, getCurrentUser, fetchUserAttributes } from "aws-amplify/auth";
import { flushSync } from "react-dom";

const { Title, Paragraph } = Typography;

export const App: React.FC = () => {
  const [jsonText, setJsonText] = useState<string>("{\n  \"items\": []\n}");
  const textAreaRef = useRef<HTMLTextAreaElement | null>(null);
  const [apiDebug, setApiDebug] = useState<number | undefined>(undefined);
  const [skip, setSkip] = useState<number>(1);
  const [limit, setLimit] = useState<number>(10);
  const [numChunks, setNumChunks] = useState<number>(1);
  useEffect(() => { setNumChunks(2); }, []);
  const [numWorkers, setNumWorkers] = useState<number>(1);
  const [confirmedWorkers, setConfirmedWorkers] = useState<number | undefined>(undefined);
  const [workersError, setWorkersError] = useState<string | undefined>(undefined);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [userEmail, setUserEmail] = useState<string | undefined>(undefined);
  const [bridgeReady, setBridgeReady] = useState<boolean>(false);
  const [bridgeAuthenticated, setBridgeAuthenticated] = useState<boolean>(false);
  const hasInitFetchedRef = useRef<boolean>(false);
  const hasUserEditedRef = useRef<boolean>(false);
  const [refAdeme, setRefAdeme] = useState<string | undefined>(undefined);
  const [simulLog, setSimulLog] = useState<string | undefined>(undefined);
  const [isSaveMenuOpen, setIsSaveMenuOpen] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [resultsUrl, setResultsUrl] = useState<string | undefined>(undefined);
  const activePollAbortRef = useRef<{ cancel: () => void } | null>(null);
  const [isPolling, setIsPolling] = useState<boolean>(false);
  const [isScenariosOpen, setIsScenariosOpen] = useState<boolean>(false);
  const [isLoadSavedOpen, setIsLoadSavedOpen] = useState<boolean>(false);
  const [isEditorOpen, setIsEditorOpen] = useState<boolean>(false);
  const [isChainlitOpen, setIsChainlitOpen] = useState<boolean>(false);
  const [queueSegments, setQueueSegments] = useState<number>(0);
  const [queueItems, setQueueItems] = useState<any[]>([]);
  const queuePollIdRef = useRef<number | null>(null);
  const [queueNowTick, setQueueNowTick] = useState<number>(0);
  function openEditor() { setIsEditorOpen(true); }
  const hasLoadedTemplateRef = useRef<boolean>(false);
  const editorOriginalTextRef = useRef<string>("");

  useEffect(() => {
    let isCancelled = false;
    // Listen to session bridge messages from auth app
    function onMessage(ev: MessageEvent) {
      try {
        const payload = ev.data;
        if (!payload || payload.type !== "cognito-session-bridge") return;
        const authOrigin = payload?.data?.authOrigin as string | undefined;
        // Optionally validate origin
        if (authOrigin && !ev.origin.startsWith(authOrigin)) {
          // origin mismatch – ignore
          return;
        }
        setBridgeReady(true);
        const isAuthenticated = Boolean(payload?.data?.isAuthenticated);
        const tokenFromBridge = (payload?.data?.accessToken as string | undefined) || undefined;
        if (tokenFromBridge) setBridgeAccessToken(tokenFromBridge);
        if (isAuthenticated) setBridgeAuthenticated(true);
        const emailFromBridge = (payload?.data?.email as string | undefined) || (payload?.data?.username as string | undefined);
        if (!isCancelled && emailFromBridge) {
          setUserEmail((prev) => prev || emailFromBridge);
        }
      } catch {}
    }
    window.addEventListener("message", onMessage);
    
    (async () => {
      try {
        const url = new URL(window.location.href);
        const ra = url.searchParams.get("ref_ademe") || undefined;
        const sim = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string | undefined) || undefined;
        if (!isCancelled) {
          setRefAdeme(ra);
          setSimulLog(sim);
        }
      } catch {}
      // Immediate cookie-based fallback for username/email
      try {
        const parts = document.cookie.split("; ").filter(Boolean);
        for (const part of parts) {
          const idx = part.indexOf("=");
          if (idx === -1) continue;
          const key = part.substring(0, idx);
          const val = part.substring(idx + 1);
          if (key.startsWith("CognitoIdentityServiceProvider.") && key.endsWith(".LastAuthUser")) {
            const raw = decodeURIComponent(val);
            if (raw && !isCancelled) {
              setUserEmail(raw);
              return; // found username from cookie; stop here
            }
          }
        }
      } catch {}

      // Fallback #2: decode idToken cookie to extract email claim
      try {
        const all = document.cookie.split("; ").filter(Boolean);
        const prefix = "CognitoIdentityServiceProvider.";
        for (const cookie of all) {
          const eq = cookie.indexOf("=");
          if (eq === -1) continue;
          const name = cookie.substring(0, eq);
          if (!name.startsWith(prefix) || !name.endsWith(".idToken")) continue;
          const raw = decodeURIComponent(cookie.substring(eq + 1));
          const parts = raw.split(".");
          if (parts.length >= 2) {
            const mid = parts[1]!;
            const payload = JSON.parse(atob(mid.replace(/-/g, "+").replace(/_/g, "/")));
            const emailClaim = (payload && (payload.email || payload.username)) as string | undefined;
            if (emailClaim && !isCancelled) {
              setUserEmail(emailClaim);
              break;
            }
          }
        }
      } catch {}

      try {
        // Prefer Cognito username (often the email) if available
        const { username } = await getCurrentUser();
        if (username && !isCancelled) {
          setUserEmail(username || undefined);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      // Try fetching user attributes (email) when available
      try {
        const attrs = await fetchUserAttributes();
        const emailAttr = attrs?.email as string | undefined;
        if (emailAttr && !isCancelled) {
          setUserEmail(emailAttr);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      try {
        const session = await fetchAuthSession();
        const emailClaim = (session as any)?.tokens?.idToken?.payload?.email as string | undefined;
        if (!isCancelled) setUserEmail(emailClaim ?? undefined);
      } catch {
        if (!isCancelled) setUserEmail(undefined);
      }
    })();
    return () => {
      isCancelled = true;
      window.removeEventListener("message", onMessage);
    };
  }, []);

  // Also try firing when bridge reports authenticated (helps cross-port first load)
  useEffect(() => {
    if (!bridgeAuthenticated || hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    (async () => {
      try {
        const token = await waitForAccessToken(15000, 250);
        if (!token) return;
        if (hasInitFetchedRef.current) return;
        hasInitFetchedRef.current = true;
        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", refAdeme);
        apiUrl.searchParams.set("log", simul);
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail (bridge)", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail (bridge)", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed (bridge)", err);
      }
    })();
    return () => controller.abort();
  }, [bridgeAuthenticated]);

  // On init: if URL contains simul=default, call template endpoint and initialize editor JSON
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        if (cancelled) return;
        if (hasLoadedTemplateRef.current) return;
        const url = new URL(window.location.href);
        const simul = url.searchParams.get("simul");
        if (simul !== "default") return;
        if (!refAdeme) return;
        if (hasUserEditedRef.current) return;

        const accessToken = await waitForAccessToken(15000, 250);
        if (!accessToken) return;

        const baseUrl = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const template = await fetchSimulationTemplateJson<any>({ baseUrl, ref_ademe: refAdeme, accessToken });
        if (cancelled) return;

        const sourceRuns: any[] = Array.isArray(template)
          ? template
          : (template && Array.isArray(template.runs) ? template.runs : []);

        const transformedRuns = sourceRuns.map((run) => {
          const forced = run?.parameters?.input_forced || {};
          const scenarios = Array.isArray(run?.scenarios) ? run.scenarios : [];
          const nextScenarios = scenarios.map((sc: any) => {
            const baseInput = (sc && sc.input && typeof sc.input === "object") ? sc.input : {};
            const mergedInput = { ...forced, ...baseInput };
            return { ...sc, input: mergedInput };
          });
          const { parameters, ...rest } = run || {};
          return { ...rest, scenarios: nextScenarios };
        });

        if (transformedRuns.length > 0) {
          hasLoadedTemplateRef.current = true;
          setJsonText(JSON.stringify(transformedRuns, null, 2));
        }
      } catch {
        // ignore
      }
    };

    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // On init: if URL contains ?ref_ademe=..., call backoffice endpoint (Bearer included when available)
  useEffect(() => {
    if (hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const apiUrl = new URL("/backoffice/get_redis_detail", base);
    apiUrl.searchParams.set("ref_ademe", refAdeme);
    apiUrl.searchParams.set("log", simul);

    async function doFetchOnce() {
      if (hasInitFetchedRef.current) return;
      hasInitFetchedRef.current = true;
      try {
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    }

    (async () => {
      try {
        // Wait for a valid access token before calling the endpoint
        const token = await waitForAccessToken(15000, 250);
        if (!token) {
          // eslint-disable-next-line no-console
          console.warn("[simulation] skipping get_redis_detail: no Cognito token available");
          return; // we'll rely on auth Hub events below if sign-in happens later
        }
        await doFetchOnce();
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    })();

    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh"){ doFetchOnce(); }
      } catch {}
    });

    // Poll as a safety net in case Hub events fired before subscribe
    const pollId = window.setInterval(async () => {
      try {
        if (hasInitFetchedRef.current) { window.clearInterval(pollId); return; }
        const token = await getAccessToken();
        if (token) {
          window.clearInterval(pollId);
          await doFetchOnce();
        }
      } catch {}
    }, 500);

    return () => {
      try { (removeHub as any)?.(); } catch {}
      try { window.clearInterval(pollId); } catch {}
      controller.abort();
    };
  }, []);

  // When only ref_ademe is present and no simul param, initialize editor to [] and open load modal (after token available)
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        const url = new URL(window.location.href);
        const hasRef = Boolean(url.searchParams.get("ref_ademe"));
        const hasSimul = url.searchParams.has("simul");
        if (hasRef && !hasSimul) {
          if (!hasUserEditedRef.current) setJsonText("[]");
          const token = await waitForAccessToken(15000, 250);
          if (cancelled) return;
          if (token) setIsLoadSavedOpen(true);
        }
      } catch {}
    };
    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // When opening with both ref_ademe and simul, expand the editor drawer by default
  useEffect(() => {
    try {
      const url = new URL(window.location.href);
      const hasRef = Boolean(url.searchParams.get("ref_ademe"));
      const simul = url.searchParams.get("simul");
      if (hasRef && simul && simul !== "default") {
        setIsEditorOpen(true);
      }
    } catch {}
  }, [refAdeme, simulLog]);

  const apiDebugOptions = useMemo(() => [
    { label: "none", value: undefined },
    { label: "1", value: 1 },
    { label: "2", value: 2 },
  ], []);

  useEffect(() => {
    return () => {
      try { activePollAbortRef.current?.cancel(); setIsPolling(false); } catch {}
    };
  }, []);

  // Capture the JSON snapshot when opening the editor to detect unconfirmed changes
  useEffect(() => {
    try {
      if (isEditorOpen) {
        editorOriginalTextRef.current = jsonText || "";
      }
    } catch {}
  }, [isEditorOpen]);

  const isEditorDirty = useMemo(() => {
    if (!isEditorOpen) return false;
    try {
      const a = (editorOriginalTextRef.current || "").trim();
      const b = (jsonText || "").trim();
      if (!a && !b) return false;
      try {
        const ap = a ? JSON.parse(a) : null;
        const bp = b ? JSON.parse(b) : null;
        return JSON.stringify(ap) !== JSON.stringify(bp);
      } catch {
        return a !== b;
      }
    } catch {
      return false;
    }
  }, [isEditorOpen, jsonText]);

  const isSubmitBlocked = isEditorOpen && isEditorDirty;

  function startPollingForResults(ref: string, log: string) {
    // cancel any previous polling
    try { activePollAbortRef.current?.cancel(); } catch {}
    let cancelled = false;
    activePollAbortRef.current = { cancel: () => { cancelled = true; setIsPolling(false); } };

    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const resultsHref = `https://bo.scandpe.fr/simulation/index.html?tab=results&dpe=${encodeURIComponent(ref)}`;

    setIsPolling(true);
    const tick = async () => {
      if (cancelled) return;
      try {
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", ref);
        apiUrl.searchParams.set("log", log);
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
        });
        if (res.ok) {
          const data = await res.json().catch(() => null);
          if (data && data.status === "processed") {
            setResultsUrl(resultsHref);
            cancelled = true;
            setIsPolling(false);
            return;
          }
        }
      } catch {}
      if (!cancelled) {
        window.setTimeout(tick, 1000);
      }
    };
    tick();
  }

  async function handleSaveToBackoffice() {
    try {
      if (!refAdeme || !simulLog) {
        message.error("Missing ref_ademe or simul");
        setIsSaveMenuOpen(false);
        return;
      }
      const ref = `${refAdeme}-${simulLog}`;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const apiUrl = new URL("/backoffice/redis_file_manage", base);
      setIsSaving(true);
      // eslint-disable-next-line no-console
      console.debug("[simulation] POST redis_file_manage", { url: apiUrl.toString(), ref });
      const res = await authorizedFetch(apiUrl.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json, text/plain, */*",
          "x-authorization": "dperdition",
        },
        body: JSON.stringify({ ref, text: jsonText }),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success(`saved ${simulLog}`);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error("redis_file_manage failed", err);
      message.error("save failed");
    } finally {
      setIsSaving(false);
      setIsSaveMenuOpen(false);
    }
  }

  async function fetchQueueOnce() {
    try {
      if (!refAdeme) return;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const simulName = simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
      const urlQueue = new URL("/backoffice/get_redis_detail", base);
      urlQueue.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlQueue.searchParams.set("log", `${simulName}_o3cl_queue`);
      const urlDone = new URL("/backoffice/get_redis_detail", base);
      urlDone.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlDone.searchParams.set("log", `${simulName}_o3cl_done_queue`);

      const [qres, dres] = await Promise.all([
        authorizedFetch(urlQueue.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
        authorizedFetch(urlDone.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
      ]);

      const parseItems = async (res: Response): Promise<any[]> => {
        if (!res.ok) return [];
        const data: any = await res.json().catch(() => null);
        if (Array.isArray(data?.items)) return data.items as any[];
        if (Array.isArray(data)) return data as any[];
        if (data && typeof data === "object" && Array.isArray((data as any).queue)) return (data as any).queue as any[];
        return [];
      };

      const [queueList, doneListRaw] = await Promise.all([parseItems(qres), parseItems(dres)]);
      const doneList = (doneListRaw || []).map((it: any) => ({ ...it, status: 1 }));
      const merged = [...doneList, ...queueList];
      setQueueItems(merged);
      setQueueSegments(merged.length || 0);
    } catch {}
  }

  function startQueuePolling() {
    try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    void fetchQueueOnce();
    const raw = (import.meta as any)?.env?.VITE_POLL_QUEUE_DELAY;
    const n = Number(raw);
    const delayMs = Number.isFinite(n) && n > 0 ? n : 30000;
    const id = window.setInterval(fetchQueueOnce, delayMs);
    queuePollIdRef.current = id;
  }

  useEffect(() => {
    return () => {
      try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    };
  }, []);

  useEffect(() => {
    if (!queueItems.length) return;
    const id = window.setInterval(() => setQueueNowTick((t) => t + 1), 1000);
    return () => { try { window.clearInterval(id); } catch {} };
  }, [queueItems.length]);

  async function handleSubmit() {
    try {
      const parsed = jsonText.trim() ? JSON.parse(jsonText) : {};
      const baseQuery = {
        api_debug: Boolean(apiDebug),
        skip,
        limit,
        ref_ademe: refAdeme,
      } as Record<string, unknown>;
      const query = { ...baseQuery, runs: parsed } as Record<string, unknown>;
      const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
      const body = {
        redis_db: 1,
        task: "tasks.ext_o3cl_managing.direct_scenarios",
        args: {
          ref_ademe: refAdeme,
          query,
        },
      };
      setSubmitting(true);
      // Use plain fetch to avoid adding Authorization header
      const res = await fetch(lambdaUrl, {
        method: "POST",
        headers: {
          Accept: "application/json, text/plain, */*",
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success("Submitted simulation");
      if (refAdeme) {
        const logName = `${(simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl")}_report_o3cl`;
        startPollingForResults(refAdeme, logName);
      }
      // If nb chunks > 1, also call append_scenarios
      if (Number(numChunks || 1) > 1) {
        const appendBody = {
          redis_db: 1,
          task: "tasks.ext_o3cl_managing.init_scenarios",
          args: {
            run_name: simulLog || "dev_report_o3cl",
            ref_ademe: refAdeme,
            nb_chunks: Number(numChunks || 1),
            nb_workers: Number(numWorkers || 1),
            nb_combination: 100,
            query,
          },
        } as Record<string, unknown>;
        try {
          const res2 = await fetch(lambdaUrl, {
            method: "POST",
            headers: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": "application/json",
            },
            body: JSON.stringify(appendBody),
          });
          if (!res2.ok) {
            const txt2 = await res2.text().catch(() => "");
            throw new Error(`HTTP ${res2.status} ${txt2}`);
          }
          message.success(`appending scenarios across ${Number(numChunks)} chunks`);
          // eslint-disable-next-line no-console
          console.debug("append_scenarios payload", appendBody);

          // Start queue polling for segmented progress
          startQueuePolling();
        } catch (e) {
          message.error("Failed to append scenarios");
        }
      }
      // eslint-disable-next-line no-console
      console.log("simulation payload", body);
    } catch (err) {
      message.error("Invalid JSON");
    } finally {
      setSubmitting(false);
    }
  }

  function handleConfirmWorkers() {
    const value = Number(numWorkers || 0);
    if (value > 10) {
      setWorkersError("Max 10 workers");
      setConfirmedWorkers(undefined);
      return;
    }
    if (value < 1) {
      setWorkersError("Min 1 worker");
      setConfirmedWorkers(undefined);
      return;
    }
    setWorkersError(undefined);
    setConfirmedWorkers(value);

    // Call scaling lambda
    const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
    const body = {
      redis_db: 1,
      task: "tasks.r_ecs_scaling.scale",
      args: {
        cluster: "checkdpe-dev-cluster",
        service: "checkdpe-cd-3cl-dev-service",
        desired: value,
      },
    };
    // eslint-disable-next-line no-console
    console.debug("[simulation] scaling workers", body);
    fetch(lambdaUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json, text/plain, */*" },
      body: JSON.stringify(body),
    })
      .then(async (res) => {
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} ${txt}`);
        }
        message.success(`updated workers to ${value}`);
      })
      .catch(() => {
        message.error("failed to update workers");
      });
  }

  return (
    <div style={{ minHeight: "100vh", background: "#ffffff", color: "#0b0c0f" }}>
      <TopMenu
        authLabel={userEmail || "login / sign-up"}
        authHref={(() => {
          const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
          if (configured) {
            try {
              const configuredUrl = new URL(configured);
              const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
              const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
              if (isConfiguredLocal && !isPageLocal) {
                // ignore local auth URL on non-localhost pages
              } else {
                // On non-local hosts, prefer explicit index.html so returnTo is added to the file URL
                if (!isConfiguredLocal) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  if (!endsWithHtml) {
                    const base = hasTrailingSlash ? configured.replace(/\/$/, "") : configured;
                    return base + "/index.html";
                  }
                }
                return configured;
              }
            } catch {
              return configured;
            }
          }
          if (window.location.hostname === "localhost") return "http://localhost:5173";
          return "/auth/index.html";
        })()}
        isAuthenticated={Boolean(userEmail)}
        centeredTitle={refAdeme}
        logoutHref={(() => {
          const domain = (import.meta.env.VITE_COGNITO_DOMAIN_URL as string | undefined)?.replace(/^https?:\/\//, "");
          if (!domain) return undefined;
          const clientId = import.meta.env.VITE_COGNITO_CLIENT_ID as string | undefined;
          const logoutRedirect = (import.meta.env.VITE_LOGOUT_REDIRECT_URL as string | undefined) || window.location.origin;
          if (!clientId) return undefined;
          return `https://${domain}/logout?client_id=${encodeURIComponent(clientId)}&logout_uri=${encodeURIComponent(logoutRedirect)}`;
        })()}
      />
      {/* Invisible iframe to pull session from auth origin when on different ports */}
      {!bridgeReady && (
        <iframe
          src={(() => {
            const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
            if (configured) {
              try {
                const configuredUrl = new URL(configured);
                const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
                const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
                if (!(isConfiguredLocal && !isPageLocal)) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  const base = endsWithHtml ? configured : (hasTrailingSlash ? configured.replace(/\/$/, "") + "/index.html" : configured + "/index.html");
                  return base;
                }
              } catch {
                return configured.replace(/\/$/, "") + "/index.html";
              }
            }
            if (window.location.hostname === "localhost") return "http://localhost:5173/index.html";
            return "/auth/index.html";
          })()}
          style={{ display: "none" }}
          title="session-bridge"
        />
      )}
      <div style={{ padding: 24 }}>
      <div style={{ display: "flex", alignItems: "flex-start", gap: 16 }}>
        {isEditorOpen ? (
          <DpeDrawerEditor
            inline
            open={isEditorOpen}
            onClose={() => setIsEditorOpen(false)}
            width={480}
            rootJsonText={jsonText}
            onApply={(next) => { hasUserEditedRef.current = true; flushSync(() => setJsonText(next)); }}
            apiLoadParams={refAdeme ? { baseUrl: (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr", ref_ademe: refAdeme } : undefined}
            getAccessToken={getAccessToken}
            onLoadedFromApi={(data) => {
              try {
                const text = JSON.stringify(data, null, 2);
                setJsonText((prev) => (prev?.trim() ? prev : text));
              } catch {}
            }}
            onHighlightJsonPath={({ collection, itemKey, indices }) => {
              try {
                const ta = textAreaRef.current;
                if (!ta) return;
                const text = ta.value;
                const variantPath = `dpe.logement.enveloppe.${collection}.${itemKey}`;
                let searchFrom = 0;
                let scopeArrayStart = -1;
                let scopeArrayEnd = -1;
                while (true) {
                  const varIdx = text.indexOf('"elements_variant"', searchFrom);
                  if (varIdx === -1) break;
                  const quoteIdx = text.indexOf('"', varIdx + 18);
                  const quoteEnd = quoteIdx !== -1 ? text.indexOf('"', quoteIdx + 1) : -1;
                  const value = quoteIdx !== -1 && quoteEnd !== -1 ? text.slice(quoteIdx + 1, quoteEnd) : '';
                  if (value === variantPath) {
                    const scopeKeyIdx = text.indexOf('"elements_scope"', varIdx);
                    if (scopeKeyIdx !== -1) {
                      const openBracket = text.indexOf('[', scopeKeyIdx);
                      if (openBracket !== -1) {
                        scopeArrayStart = openBracket;
                        const closeBracket = text.indexOf(']', openBracket);
                        if (closeBracket !== -1) scopeArrayEnd = closeBracket + 1;
                      }
                    }
                    break;
                  }
                  searchFrom = varIdx + 1;
                }
                if (scopeArrayStart === -1 || scopeArrayEnd === -1) return;
                const prevSelStart = ta.selectionStart;
                const prevSelEnd = ta.selectionEnd;
                const prevScrollTop = ta.scrollTop;
                const prevScrollLeft = ta.scrollLeft;
                try { (ta as any).focus({ preventScroll: true }); } catch { try { ta.focus(); } catch {} }
                try { ta.setSelectionRange(scopeArrayStart, scopeArrayEnd); } catch {}
                try { ta.scrollTop = prevScrollTop; ta.scrollLeft = prevScrollLeft; } catch {}
                window.setTimeout(() => {
                  try {
                    (ta as any).focus({ preventScroll: true });
                    ta.setSelectionRange(prevSelStart, prevSelEnd);
                    ta.scrollTop = prevScrollTop;
                    ta.scrollLeft = prevScrollLeft;
                  } catch {}
                }, 600);
              } catch {}
            }}
          />
        ) : null}

        <div style={{ flex: 1 }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12 }}>
            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
              <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Simulation</Title>
              <Button type="primary" size="large" icon={<LeftOutlined />} onClick={openEditor} disabled={isEditorOpen}>Edit</Button>
            </div>
            <Button onClick={() => setIsChainlitOpen(true)}>build with AI</Button>
          </div>
          <Paragraph style={{ color: "#4b5563", marginTop: 4 }}>Provide JSON and configure options, then submit.</Paragraph>
          
          <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
            <div style={{ display: "grid" }}>
              <textarea
                ref={textAreaRef}
                value={jsonText}
                onChange={(e) => { hasUserEditedRef.current = true; setJsonText(e.target.value); }}
                placeholder="Paste or write JSON here"
                style={{
                  minHeight: 420,
                  width: "100%",
                  background: isEditorOpen ? "#f3f4f6" : "#ffffff",
                  color: isEditorOpen ? "#6b7280" : "#111827",
                  border: "1px solid #e5e7eb",
                  borderRadius: 8,
                  padding: 12,
                  fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace",
                  fontSize: 14,
                  lineHeight: 1.45,
                  resize: "vertical",
                  cursor: isEditorOpen ? "default" : "text",
                  overflow: "auto",
                }}
                readOnly={isEditorOpen}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <Collapse
                destroyOnHidden
                items={[
                  {
                    key: "options",
                    label: "Options",
                    children: (
                      <Space direction="vertical" size={12} style={{ width: "100%" }}>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>api_debug</div>
                          <Select
                            value={apiDebug as number | undefined}
                            onChange={(v) => setApiDebug(v)}
                            allowClear
                            placeholder="none"
                            options={apiDebugOptions}
                            style={{ width: "100%" }}
                          />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>skip</div>
                          <InputNumber value={skip} onChange={(v) => setSkip(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>limit</div>
                          <InputNumber value={limit} onChange={(v) => setLimit(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb chunks</div>
                          <InputNumber value={numChunks} onChange={(v) => setNumChunks(Number(v ?? 1))} style={{ width: "100%" }} min={1} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb workers</div>
                          <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                            <InputNumber value={numWorkers} onChange={(v) => { setWorkersError(undefined); setNumWorkers(Number(v ?? 1)); }} style={{ width: 140 }} min={1} />
                            <Button size="small" onClick={handleConfirmWorkers}>ok</Button>
                            {typeof confirmedWorkers === "number" && (
                              <span style={{ color: "#059669", fontSize: 12 }}>saved: {confirmedWorkers}</span>
                            )}
                          </div>
                          {workersError && (
                            <div style={{ marginTop: 4, color: "#ef4444", fontSize: 12 }}>{workersError}</div>
                          )}
                        </div>
                      </Space>
                    ),
                  },
                ]}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <div style={{ display: "flex", gap: 8, justifyContent: "flex-end", alignItems: "center" }}>
                <Tooltip title={isSubmitBlocked ? "confirm simulation with OK (left panel), first." : undefined}>
                  <span style={{ display: "inline-block" }}>
                    <Button type="primary" onClick={handleSubmit} loading={submitting} disabled={isSubmitBlocked}>submit</Button>
                  </span>
                </Tooltip>
                <div style={{ position: "relative" }}>
                  <Button onClick={() => setIsSaveMenuOpen((v) => !v)}>...</Button>
                  {isSaveMenuOpen && (
                    <div style={{ position: "absolute", right: 0, top: "100%", background: "#fff", border: "1px solid #e5e7eb", borderRadius: 8, padding: 8, width: 260, boxShadow: "0 4px 14px rgba(0,0,0,0.08)", zIndex: 10 }}>
                    <div style={{ padding: "6px 8px", cursor: "pointer", borderRadius: 6 }} onClick={() => { setIsLoadSavedOpen(true); setIsSaveMenuOpen(false); }}>load scenario</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={() => { if (!isSaving) handleSaveToBackoffice(); }}>save {simulLog || "default"}</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={async () => {
                      if (isSaving) return;
                      const cdEnv = ((import.meta as any)?.env?.VITE_CD_ENV as string | undefined) || (import.meta.env.MODE === "development" ? "dev" : "prod");
                      const suggested = `${cdEnv}_simul_${simulLog || "test0001"}`;
                      const name = window.prompt(
                        "Save as name (format: <CD_ENV>_simul_<name>, e.g., dev_simul_test0001):",
                        suggested
                      );
                      if (!name) { setIsSaveMenuOpen(false); return; }
                      try {
                        const ref = `${refAdeme || "unknown"}-${name}`;
                        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
                        const apiUrl = new URL("/backoffice/redis_file_manage", base);
                        setIsSaving(true);
                        // eslint-disable-next-line no-console
                        console.debug("[simulation] POST redis_file_manage (save as)", { url: apiUrl.toString(), ref });
                        const res = await authorizedFetch(apiUrl.toString(), {
                          method: "POST",
                          headers: {
                            "Content-Type": "application/json",
                            Accept: "application/json, text/plain, */*",
                            "x-authorization": "dperdition",
                          },
                          body: JSON.stringify({ ref, text: jsonText }),
                        });
                        if (!res.ok) {
                          const txt = await res.text().catch(() => "");
                          throw new Error(`HTTP ${res.status} ${txt}`);
                        }
                        message.success(`saved ${name}`);
                        if (refAdeme) {
                          const { origin, pathname } = window.location;
                          const basePath = (() => {
                            try {
                              const idx = pathname.lastIndexOf("/");
                              return idx !== -1 ? pathname.slice(0, idx + 1) : "/";
                            } catch {
                              return "/";
                            }
                          })();
                          const targetUrl = `${origin}${basePath}index.html?ref_ademe=${encodeURIComponent(refAdeme)}&simul=${encodeURIComponent(name)}`;
                          window.location.href = targetUrl;
                        }
                      } catch {
                        message.error("save failed");
                      } finally {
                        setIsSaving(false);
                        setIsSaveMenuOpen(false);
                      }
                    }}>save as…</div>
                    </div>
                  )}
                </div>
              </div>
              <div style={{ marginTop: 8, display: "flex", justifyContent: "flex-start", minHeight: 24 }}>
                {!resultsUrl && isPolling && (
                  <Spin size="small" />
                )}
                {resultsUrl && (
                  <a href={resultsUrl} target="_blank" rel="noopener noreferrer" style={{ display: "inline-flex", alignItems: "center", gap: 6 }}>
                    Open simulation results <ExportOutlined />
                  </a>
                )}
              </div>
              {refAdeme ? (
                <div style={{ marginTop: 20 }}>
                  <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12, marginBottom: 12 }}>
                    <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Results preview</Title>
                  </div>
                  <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
                    <SimulationResults
                      dpeId={refAdeme}
                      getAccessToken={async () => (await getAccessToken()) || undefined}
                      apiBaseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
                      width={720}
                      height={300}
                    />
                  </Card>
                </div>
              ) : null}
              {queueSegments > 0 && (
                <div style={{ marginTop: 12 }}>
                  <div style={{ height: 10, background: "#e5e7eb", borderRadius: 8, overflow: "hidden", display: "flex" }}>
                    {(queueItems.length ? queueItems : Array.from({ length: queueSegments })).map((item: any, idx: number) => {
                      const ts = item?.ts_started;
                      let startedAtMs = 0;
                      try {
                        if (typeof ts === "number") startedAtMs = ts > 1e12 ? ts : ts * 1000;
                        else if (typeof ts === "string") {
                          const n = Number(ts);
                          if (Number.isFinite(n)) startedAtMs = n > 1e12 ? n : n * 1000; else {
                            const t = Date.parse(ts);
                            if (!Number.isNaN(t)) startedAtMs = t;
                          }
                        }
                      } catch {}
                      const elapsedSec = Math.max(0, (Date.now() - startedAtMs) / 1000);
                      const statusNum = Number(item?.status ?? 0);
                      const pct = statusNum === 1 ? 100 : Math.max(0, Math.min(100, (elapsedSec / 60) * 100));
                      const fillColor = statusNum === 1 ? "#93c5fd" : "transparent";
                      return (
                        <div key={idx} style={{ flex: 1, display: "flex" }}>
                          <div style={{ width: `${pct}%`, background: fillColor, transition: "width 1s linear" }} />
                          {idx < queueSegments - 1 ? (
                            <div style={{ width: 2, background: "#ffffff" }} />
                          ) : null}
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              {/* editor inline panel is rendered on the right */}
            </div>
            <SimulationScenariosModal
              open={isScenariosOpen}
              onCancel={() => setIsScenariosOpen(false)}
              onLoad={(runs) => {
                try {
                  setJsonText(JSON.stringify(runs, null, 2));
                } catch {
                  // fallback to empty array
                  setJsonText(JSON.stringify([], null, 2));
                }
                setIsScenariosOpen(false);
              }}
            />
            <LoadScenarioModal
              open={isLoadSavedOpen}
              onCancel={() => setIsLoadSavedOpen(false)}
              onSelect={(payload: unknown) => {
                try {
                  // Accept payload either as normalized object { ref_ademe, label } or string "ref:label"
                  let ref: string | undefined;
                  let simul: string | undefined;
                  if (typeof payload === "string") {
                    const colon = payload.indexOf(":");
                    ref = colon !== -1 ? payload.slice(0, colon) : undefined;
                    simul = colon !== -1 ? payload.slice(colon + 1) : undefined;
                  } else if (payload && typeof payload === "object") {
                    ref = (payload as any).ref_ademe as string | undefined;
                    simul = (payload as any).label as string | undefined;
                  }
                  const url = new URL(window.location.href);
                  if (ref) url.searchParams.set("ref_ademe", ref);
                  if (simul) url.searchParams.set("simul", simul);
                  window.location.href = url.toString();
                } catch {}
                setIsLoadSavedOpen(false);
              }}
              baseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
              initialRefAdeme={refAdeme}
              getAccessToken={getAccessToken}
            />
          </Card>
        </div>

        {(() => {
          const chainlitUrl = (() => {
            const configured = import.meta.env.VITE_CHAINLIT_URL as string | undefined;
            if (configured && typeof configured === "string" && configured.trim()) return configured.trim();
            return "https://chainlit-stg.etiquettedpe.fr/chainlit";
          })();
          return (
            <ChainlitChatDrawer
              open={isChainlitOpen}
              onClose={() => setIsChainlitOpen(false)}
              title="Assistant"
              serverUrl={chainlitUrl}
              userEnv={{
                mail: "germain.blanchet@gmail.com",
                button_id: "contactez_nous",
                ref_ademe: refAdeme || "2508E0243162W",
              }}
            />
          );
        })()}

      </div>
      </div>
    </div>
  );
};



```

Done. The loader/progress area now stays directly under the submit button by left-aligning that row. The results preview remains below, as requested.

---

**User**

Simulation : 
after submit we can stop polling this : 
curl 'https://api-dev.etiquettedpe.fr/backoffice/get_redis_detail?ref_ademe=2508E0243162W&log=dev_simul_test0002_report_o3cl' \
  -H 'accept: application/json, text/plain, */*' \
  -H 'accept-language: en-US,en;q=0.9,fr-FR;q=0.8,fr;q=0.7,la;q=0.6' \
  -H 'authorization: Bearer eyJraWQiOiJ4Q01ha3d1TElLbEh5b1pDTVpKMlZNeG5UazNUa2hUcEtZdXNtbmJXV1l3PSIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiIyMWU5ZDA5ZS02MDYxLTcwOWMtOWFmNS0wOGFiNjk1YTI5NzMiLCJpc3MiOiJodHRwczpcL1wvY29nbml0by1pZHAuZXUtd2VzdC0zLmFtYXpvbmF3cy5jb21cL2V1LXdlc3QtM18yTmhtUWZQZzkiLCJjbGllbnRfaWQiOiIxazlsdnZsbmhzMzIwb2tjdHJrbGNrZWg1MCIsIm9yaWdpbl9qdGkiOiI1YTQ4MDZkYS1mYzRiLTQ1NWYtOGRmNC1lNDEzYjI2MDAyODEiLCJldmVudF9pZCI6IjAzOTViYzgzLWNlMTAtNDAzYy1hNmZhLWRhN2Y4YWNmZGRkNyIsInRva2VuX3VzZSI6ImFjY2VzcyIsInNjb3BlIjoiYXdzLmNvZ25pdG8uc2lnbmluLnVzZXIuYWRtaW4iLCJhdXRoX3RpbWUiOjE3NTg1NDU2OTksImV4cCI6MTc1ODg5MjcwMCwiaWF0IjoxNzU4ODA2MzAwLCJqdGkiOiIxMGY4MDViZS04OGJhLTRlNDEtYmY3Mi02Y2Y2N2ExODYwMjEiLCJ1c2VybmFtZSI6Imdlcm1haW4uYmxhbmNoZXRAZ21haWwuY29tIn0.dM4KOzWjUIWKiOYl-IDYMVteUw_L3Tp2g8W3_dDl5GiU2aihRDC_3Q3yix0uCXhdo6SoGtyyhiRIgIzk9FXyvRL2VW3K07kDAwuIAXVfxTkfRvMGBSSusg00eFjVsyIx0SpnxJ3oyNs832kjtQOZZ3AYeDSbROXSQq7tdumh6Azak8nnKbi974pHd7Au6Wcm1gxLUXjD9itSrntGK5IiWRsuqgdvTWIDJ18vEB5XT9xLmfo7YuVxyqbqhQoHCGmnd-ErFU0TKJ9NdA2icwz9VuAL_8bmMgqvqstp09hXAvtxxxUl5-FxL-7h5VyAHoWgSLPKq0B1dHuq6WyQj2bICw' \
  -H 'cache-control: no-cache' \
  -H 'origin: http://localhost:3000' \
  -H 'pragma: no-cache' \
  -H 'priority: u=1, i' \
  -H 'referer: http://localhost:3000/' \
  -H 'sec-ch-ua: "Chromium";v="140", "Not=A?Brand";v="24", "Google Chrome";v="140"' \
  -H 'sec-ch-ua-mobile: ?0' \
  -H 'sec-ch-ua-platform: "macOS"' \
  -H 'sec-fetch-dest: empty' \
  -H 'sec-fetch-mode: cors' \
  -H 'sec-fetch-site: cross-site' \
  -H 'user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36' \
  -H 'x-authorization: dperdition'

---

**Cursor**

I'll remove the results polling trigger in handleSubmit so we stop calling get_redis_detail for the report status after submit, and ensure any existing polling is canceled. Then I'll run a lint check.

```typescriptreact
import React, { useEffect, useMemo, useRef, useState } from "react";
import "./amplify";
import { authorizedFetch, waitForAccessToken, getAccessToken, setBridgeAccessToken } from "./auth";
import { Hub } from "aws-amplify/utils";
import { Button, Card, Col, Flex, Input, InputNumber, Row, Select, Space, Typography, message, Spin, Collapse, Tooltip } from "antd";
import { ExportOutlined, LeftOutlined } from "@ant-design/icons";
import { SimulationScenariosModal } from "@acme/simulation-scenarios";
import { LoadScenarioModal } from "@acme/load-scenario";
import { DpeDrawerEditor, fetchSimulationTemplateJson } from "@acme/dpe-editor";
import { SimulationResults } from "@acme/simulation-results";
import { ChainlitChatDrawer } from "@acme/chainlit-client";
import { TopMenu } from "@acme/top-menu";
import { fetchAuthSession, getCurrentUser, fetchUserAttributes } from "aws-amplify/auth";
import { flushSync } from "react-dom";

const { Title, Paragraph } = Typography;

export const App: React.FC = () => {
  const [jsonText, setJsonText] = useState<string>("{\n  \"items\": []\n}");
  const textAreaRef = useRef<HTMLTextAreaElement | null>(null);
  const [apiDebug, setApiDebug] = useState<number | undefined>(undefined);
  const [skip, setSkip] = useState<number>(1);
  const [limit, setLimit] = useState<number>(10);
  const [numChunks, setNumChunks] = useState<number>(1);
  useEffect(() => { setNumChunks(2); }, []);
  const [numWorkers, setNumWorkers] = useState<number>(1);
  const [confirmedWorkers, setConfirmedWorkers] = useState<number | undefined>(undefined);
  const [workersError, setWorkersError] = useState<string | undefined>(undefined);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [userEmail, setUserEmail] = useState<string | undefined>(undefined);
  const [bridgeReady, setBridgeReady] = useState<boolean>(false);
  const [bridgeAuthenticated, setBridgeAuthenticated] = useState<boolean>(false);
  const hasInitFetchedRef = useRef<boolean>(false);
  const hasUserEditedRef = useRef<boolean>(false);
  const [refAdeme, setRefAdeme] = useState<string | undefined>(undefined);
  const [simulLog, setSimulLog] = useState<string | undefined>(undefined);
  const [isSaveMenuOpen, setIsSaveMenuOpen] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [resultsUrl, setResultsUrl] = useState<string | undefined>(undefined);
  const activePollAbortRef = useRef<{ cancel: () => void } | null>(null);
  const [isPolling, setIsPolling] = useState<boolean>(false);
  const [isScenariosOpen, setIsScenariosOpen] = useState<boolean>(false);
  const [isLoadSavedOpen, setIsLoadSavedOpen] = useState<boolean>(false);
  const [isEditorOpen, setIsEditorOpen] = useState<boolean>(false);
  const [isChainlitOpen, setIsChainlitOpen] = useState<boolean>(false);
  const [queueSegments, setQueueSegments] = useState<number>(0);
  const [queueItems, setQueueItems] = useState<any[]>([]);
  const queuePollIdRef = useRef<number | null>(null);
  const [queueNowTick, setQueueNowTick] = useState<number>(0);
  function openEditor() { setIsEditorOpen(true); }
  const hasLoadedTemplateRef = useRef<boolean>(false);
  const editorOriginalTextRef = useRef<string>("");

  useEffect(() => {
    let isCancelled = false;
    // Listen to session bridge messages from auth app
    function onMessage(ev: MessageEvent) {
      try {
        const payload = ev.data;
        if (!payload || payload.type !== "cognito-session-bridge") return;
        const authOrigin = payload?.data?.authOrigin as string | undefined;
        // Optionally validate origin
        if (authOrigin && !ev.origin.startsWith(authOrigin)) {
          // origin mismatch – ignore
          return;
        }
        setBridgeReady(true);
        const isAuthenticated = Boolean(payload?.data?.isAuthenticated);
        const tokenFromBridge = (payload?.data?.accessToken as string | undefined) || undefined;
        if (tokenFromBridge) setBridgeAccessToken(tokenFromBridge);
        if (isAuthenticated) setBridgeAuthenticated(true);
        const emailFromBridge = (payload?.data?.email as string | undefined) || (payload?.data?.username as string | undefined);
        if (!isCancelled && emailFromBridge) {
          setUserEmail((prev) => prev || emailFromBridge);
        }
      } catch {}
    }
    window.addEventListener("message", onMessage);
    
    (async () => {
      try {
        const url = new URL(window.location.href);
        const ra = url.searchParams.get("ref_ademe") || undefined;
        const sim = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string | undefined) || undefined;
        if (!isCancelled) {
          setRefAdeme(ra);
          setSimulLog(sim);
        }
      } catch {}
      // Immediate cookie-based fallback for username/email
      try {
        const parts = document.cookie.split("; ").filter(Boolean);
        for (const part of parts) {
          const idx = part.indexOf("=");
          if (idx === -1) continue;
          const key = part.substring(0, idx);
          const val = part.substring(idx + 1);
          if (key.startsWith("CognitoIdentityServiceProvider.") && key.endsWith(".LastAuthUser")) {
            const raw = decodeURIComponent(val);
            if (raw && !isCancelled) {
              setUserEmail(raw);
              return; // found username from cookie; stop here
            }
          }
        }
      } catch {}

      // Fallback #2: decode idToken cookie to extract email claim
      try {
        const all = document.cookie.split("; ").filter(Boolean);
        const prefix = "CognitoIdentityServiceProvider.";
        for (const cookie of all) {
          const eq = cookie.indexOf("=");
          if (eq === -1) continue;
          const name = cookie.substring(0, eq);
          if (!name.startsWith(prefix) || !name.endsWith(".idToken")) continue;
          const raw = decodeURIComponent(cookie.substring(eq + 1));
          const parts = raw.split(".");
          if (parts.length >= 2) {
            const mid = parts[1]!;
            const payload = JSON.parse(atob(mid.replace(/-/g, "+").replace(/_/g, "/")));
            const emailClaim = (payload && (payload.email || payload.username)) as string | undefined;
            if (emailClaim && !isCancelled) {
              setUserEmail(emailClaim);
              break;
            }
          }
        }
      } catch {}

      try {
        // Prefer Cognito username (often the email) if available
        const { username } = await getCurrentUser();
        if (username && !isCancelled) {
          setUserEmail(username || undefined);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      // Try fetching user attributes (email) when available
      try {
        const attrs = await fetchUserAttributes();
        const emailAttr = attrs?.email as string | undefined;
        if (emailAttr && !isCancelled) {
          setUserEmail(emailAttr);
          return;
        }
      } catch {
        // ignore and fallback to token claim below
      }

      try {
        const session = await fetchAuthSession();
        const emailClaim = (session as any)?.tokens?.idToken?.payload?.email as string | undefined;
        if (!isCancelled) setUserEmail(emailClaim ?? undefined);
      } catch {
        if (!isCancelled) setUserEmail(undefined);
      }
    })();
    return () => {
      isCancelled = true;
      window.removeEventListener("message", onMessage);
    };
  }, []);

  // Also try firing when bridge reports authenticated (helps cross-port first load)
  useEffect(() => {
    if (!bridgeAuthenticated || hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    (async () => {
      try {
        const token = await waitForAccessToken(15000, 250);
        if (!token) return;
        if (hasInitFetchedRef.current) return;
        hasInitFetchedRef.current = true;
        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", refAdeme);
        apiUrl.searchParams.set("log", simul);
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail (bridge)", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail (bridge)", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed (bridge)", err);
      }
    })();
    return () => controller.abort();
  }, [bridgeAuthenticated]);

  // On init: if URL contains simul=default, call template endpoint and initialize editor JSON
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        if (cancelled) return;
        if (hasLoadedTemplateRef.current) return;
        const url = new URL(window.location.href);
        const simul = url.searchParams.get("simul");
        if (simul !== "default") return;
        if (!refAdeme) return;
        if (hasUserEditedRef.current) return;

        const accessToken = await waitForAccessToken(15000, 250);
        if (!accessToken) return;

        const baseUrl = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
        const template = await fetchSimulationTemplateJson<any>({ baseUrl, ref_ademe: refAdeme, accessToken });
        if (cancelled) return;

        const sourceRuns: any[] = Array.isArray(template)
          ? template
          : (template && Array.isArray(template.runs) ? template.runs : []);

        const transformedRuns = sourceRuns.map((run) => {
          const forced = run?.parameters?.input_forced || {};
          const scenarios = Array.isArray(run?.scenarios) ? run.scenarios : [];
          const nextScenarios = scenarios.map((sc: any) => {
            const baseInput = (sc && sc.input && typeof sc.input === "object") ? sc.input : {};
            const mergedInput = { ...forced, ...baseInput };
            return { ...sc, input: mergedInput };
          });
          const { parameters, ...rest } = run || {};
          return { ...rest, scenarios: nextScenarios };
        });

        if (transformedRuns.length > 0) {
          hasLoadedTemplateRef.current = true;
          setJsonText(JSON.stringify(transformedRuns, null, 2));
        }
      } catch {
        // ignore
      }
    };

    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // On init: if URL contains ?ref_ademe=..., call backoffice endpoint (Bearer included when available)
  useEffect(() => {
    if (hasInitFetchedRef.current) return;
    const url = new URL(window.location.href);
    const refAdeme = url.searchParams.get("ref_ademe");
    const hasSimulParam = url.searchParams.has("simul");
    if (!hasSimulParam) return; // do not auto-fetch when simul is not explicitly provided
    const simul = url.searchParams.get("simul") || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
    if (simul === "default") return;
    if (!refAdeme) return;

    const controller = new AbortController();
    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const apiUrl = new URL("/backoffice/get_redis_detail", base);
    apiUrl.searchParams.set("ref_ademe", refAdeme);
    apiUrl.searchParams.set("log", simul);

    async function doFetchOnce() {
      if (hasInitFetchedRef.current) return;
      hasInitFetchedRef.current = true;
      try {
        // eslint-disable-next-line no-console
        console.debug("[simulation] calling get_redis_detail", apiUrl.toString());
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json().catch(() => null);
        if (data && !hasUserEditedRef.current) {
          setJsonText(JSON.stringify(data, null, 2));
        }
        // eslint-disable-next-line no-console
        console.log("get_redis_detail", data);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    }

    (async () => {
      try {
        // Wait for a valid access token before calling the endpoint
        const token = await waitForAccessToken(15000, 250);
        if (!token) {
          // eslint-disable-next-line no-console
          console.warn("[simulation] skipping get_redis_detail: no Cognito token available");
          return; // we'll rely on auth Hub events below if sign-in happens later
        }
        await doFetchOnce();
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("get_redis_detail failed", err);
      }
    })();

    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh"){ doFetchOnce(); }
      } catch {}
    });

    // Poll as a safety net in case Hub events fired before subscribe
    const pollId = window.setInterval(async () => {
      try {
        if (hasInitFetchedRef.current) { window.clearInterval(pollId); return; }
        const token = await getAccessToken();
        if (token) {
          window.clearInterval(pollId);
          await doFetchOnce();
        }
      } catch {}
    }, 500);

    return () => {
      try { (removeHub as any)?.(); } catch {}
      try { window.clearInterval(pollId); } catch {}
      controller.abort();
    };
  }, []);

  // When only ref_ademe is present and no simul param, initialize editor to [] and open load modal (after token available)
  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      try {
        const url = new URL(window.location.href);
        const hasRef = Boolean(url.searchParams.get("ref_ademe"));
        const hasSimul = url.searchParams.has("simul");
        if (hasRef && !hasSimul) {
          if (!hasUserEditedRef.current) setJsonText("[]");
          const token = await waitForAccessToken(15000, 250);
          if (cancelled) return;
          if (token) setIsLoadSavedOpen(true);
        }
      } catch {}
    };
    run();
    const removeHub = Hub.listen("auth", (capsule) => {
      try {
        const event = (capsule as any)?.payload?.event as string | undefined;
        if (!event) return;
        if (event === "signedIn" || event === "tokenRefresh") { run(); }
      } catch {}
    });
    return () => { try { (removeHub as any)?.(); } catch {}; cancelled = true; };
  }, [refAdeme]);

  // When opening with both ref_ademe and simul, expand the editor drawer by default
  useEffect(() => {
    try {
      const url = new URL(window.location.href);
      const hasRef = Boolean(url.searchParams.get("ref_ademe"));
      const simul = url.searchParams.get("simul");
      if (hasRef && simul && simul !== "default") {
        setIsEditorOpen(true);
      }
    } catch {}
  }, [refAdeme, simulLog]);

  const apiDebugOptions = useMemo(() => [
    { label: "none", value: undefined },
    { label: "1", value: 1 },
    { label: "2", value: 2 },
  ], []);

  useEffect(() => {
    return () => {
      try { activePollAbortRef.current?.cancel(); setIsPolling(false); } catch {}
    };
  }, []);

  // Capture the JSON snapshot when opening the editor to detect unconfirmed changes
  useEffect(() => {
    try {
      if (isEditorOpen) {
        editorOriginalTextRef.current = jsonText || "";
      }
    } catch {}
  }, [isEditorOpen]);

  const isEditorDirty = useMemo(() => {
    if (!isEditorOpen) return false;
    try {
      const a = (editorOriginalTextRef.current || "").trim();
      const b = (jsonText || "").trim();
      if (!a && !b) return false;
      try {
        const ap = a ? JSON.parse(a) : null;
        const bp = b ? JSON.parse(b) : null;
        return JSON.stringify(ap) !== JSON.stringify(bp);
      } catch {
        return a !== b;
      }
    } catch {
      return false;
    }
  }, [isEditorOpen, jsonText]);

  const isSubmitBlocked = isEditorOpen && isEditorDirty;

  function startPollingForResults(ref: string, log: string) {
    // cancel any previous polling
    try { activePollAbortRef.current?.cancel(); } catch {}
    let cancelled = false;
    activePollAbortRef.current = { cancel: () => { cancelled = true; setIsPolling(false); } };

    const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
    const resultsHref = `https://bo.scandpe.fr/simulation/index.html?tab=results&dpe=${encodeURIComponent(ref)}`;

    setIsPolling(true);
    const tick = async () => {
      if (cancelled) return;
      try {
        const apiUrl = new URL("/backoffice/get_redis_detail", base);
        apiUrl.searchParams.set("ref_ademe", ref);
        apiUrl.searchParams.set("log", log);
        const res = await authorizedFetch(apiUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json, text/plain, */*",
            "x-authorization": "dperdition",
            "Cache-Control": "no-cache",
            Pragma: "no-cache",
          },
        });
        if (res.ok) {
          const data = await res.json().catch(() => null);
          if (data && data.status === "processed") {
            setResultsUrl(resultsHref);
            cancelled = true;
            setIsPolling(false);
            return;
          }
        }
      } catch {}
      if (!cancelled) {
        window.setTimeout(tick, 1000);
      }
    };
    tick();
  }

  async function handleSaveToBackoffice() {
    try {
      if (!refAdeme || !simulLog) {
        message.error("Missing ref_ademe or simul");
        setIsSaveMenuOpen(false);
        return;
      }
      const ref = `${refAdeme}-${simulLog}`;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const apiUrl = new URL("/backoffice/redis_file_manage", base);
      setIsSaving(true);
      // eslint-disable-next-line no-console
      console.debug("[simulation] POST redis_file_manage", { url: apiUrl.toString(), ref });
      const res = await authorizedFetch(apiUrl.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json, text/plain, */*",
          "x-authorization": "dperdition",
        },
        body: JSON.stringify({ ref, text: jsonText }),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success(`saved ${simulLog}`);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error("redis_file_manage failed", err);
      message.error("save failed");
    } finally {
      setIsSaving(false);
      setIsSaveMenuOpen(false);
    }
  }

  async function fetchQueueOnce() {
    try {
      if (!refAdeme) return;
      const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
      const simulName = simulLog || (import.meta.env.VITE_BACKOFFICE_LOG as string) || "dev_report_o3cl";
      const urlQueue = new URL("/backoffice/get_redis_detail", base);
      urlQueue.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlQueue.searchParams.set("log", `${simulName}_o3cl_queue`);
      const urlDone = new URL("/backoffice/get_redis_detail", base);
      urlDone.searchParams.set("ref_ademe", String(refAdeme || ""));
      urlDone.searchParams.set("log", `${simulName}_o3cl_done_queue`);

      const [qres, dres] = await Promise.all([
        authorizedFetch(urlQueue.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
        authorizedFetch(urlDone.toString(), { method: "GET", headers: { Accept: "application/json, text/plain, */*", "x-authorization": "dperdition", "Cache-Control": "no-cache", Pragma: "no-cache" } }),
      ]);

      const parseItems = async (res: Response): Promise<any[]> => {
        if (!res.ok) return [];
        const data: any = await res.json().catch(() => null);
        if (Array.isArray(data?.items)) return data.items as any[];
        if (Array.isArray(data)) return data as any[];
        if (data && typeof data === "object" && Array.isArray((data as any).queue)) return (data as any).queue as any[];
        return [];
      };

      const [queueList, doneListRaw] = await Promise.all([parseItems(qres), parseItems(dres)]);
      const doneList = (doneListRaw || []).map((it: any) => ({ ...it, status: 1 }));
      const merged = [...doneList, ...queueList];
      setQueueItems(merged);
      setQueueSegments(merged.length || 0);
    } catch {}
  }

  function startQueuePolling() {
    try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    void fetchQueueOnce();
    const raw = (import.meta as any)?.env?.VITE_POLL_QUEUE_DELAY;
    const n = Number(raw);
    const delayMs = Number.isFinite(n) && n > 0 ? n : 30000;
    const id = window.setInterval(fetchQueueOnce, delayMs);
    queuePollIdRef.current = id;
  }

  useEffect(() => {
    return () => {
      try { if (queuePollIdRef.current != null) { window.clearInterval(queuePollIdRef.current); queuePollIdRef.current = null; } } catch {}
    };
  }, []);

  useEffect(() => {
    if (!queueItems.length) return;
    const id = window.setInterval(() => setQueueNowTick((t) => t + 1), 1000);
    return () => { try { window.clearInterval(id); } catch {} };
  }, [queueItems.length]);

  async function handleSubmit() {
    try {
      const parsed = jsonText.trim() ? JSON.parse(jsonText) : {};
      const baseQuery = {
        api_debug: Boolean(apiDebug),
        skip,
        limit,
        ref_ademe: refAdeme,
      } as Record<string, unknown>;
      const query = { ...baseQuery, runs: parsed } as Record<string, unknown>;
      const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
      const body = {
        redis_db: 1,
        task: "tasks.ext_o3cl_managing.direct_scenarios",
        args: {
          ref_ademe: refAdeme,
          query,
        },
      };
      setSubmitting(true);
      // Use plain fetch to avoid adding Authorization header
      const res = await fetch(lambdaUrl, {
        method: "POST",
        headers: {
          Accept: "application/json, text/plain, */*",
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${txt}`);
      }
      message.success("Submitted simulation");
      try { activePollAbortRef.current?.cancel(); } catch {}
      setIsPolling(false);
      // If nb chunks > 1, also call append_scenarios
      if (Number(numChunks || 1) > 1) {
        const appendBody = {
          redis_db: 1,
          task: "tasks.ext_o3cl_managing.init_scenarios",
          args: {
            run_name: simulLog || "dev_report_o3cl",
            ref_ademe: refAdeme,
            nb_chunks: Number(numChunks || 1),
            nb_workers: Number(numWorkers || 1),
            nb_combination: 100,
            query,
          },
        } as Record<string, unknown>;
        try {
          const res2 = await fetch(lambdaUrl, {
            method: "POST",
            headers: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": "application/json",
            },
            body: JSON.stringify(appendBody),
          });
          if (!res2.ok) {
            const txt2 = await res2.text().catch(() => "");
            throw new Error(`HTTP ${res2.status} ${txt2}`);
          }
          message.success(`appending scenarios across ${Number(numChunks)} chunks`);
          // eslint-disable-next-line no-console
          console.debug("append_scenarios payload", appendBody);

          // Start queue polling for segmented progress
          startQueuePolling();
        } catch (e) {
          message.error("Failed to append scenarios");
        }
      }
      // eslint-disable-next-line no-console
      console.log("simulation payload", body);
    } catch (err) {
      message.error("Invalid JSON");
    } finally {
      setSubmitting(false);
    }
  }

  function handleConfirmWorkers() {
    const value = Number(numWorkers || 0);
    if (value > 10) {
      setWorkersError("Max 10 workers");
      setConfirmedWorkers(undefined);
      return;
    }
    if (value < 1) {
      setWorkersError("Min 1 worker");
      setConfirmedWorkers(undefined);
      return;
    }
    setWorkersError(undefined);
    setConfirmedWorkers(value);

    // Call scaling lambda
    const lambdaUrl = (import.meta.env.VITE_SIMULATION_LAMBDA_URL as string) || "https://6vyebgqw4plhmxrewmsgh6yere0bwpos.lambda-url.eu-west-3.on.aws/";
    const body = {
      redis_db: 1,
      task: "tasks.r_ecs_scaling.scale",
      args: {
        cluster: "checkdpe-dev-cluster",
        service: "checkdpe-cd-3cl-dev-service",
        desired: value,
      },
    };
    // eslint-disable-next-line no-console
    console.debug("[simulation] scaling workers", body);
    fetch(lambdaUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json, text/plain, */*" },
      body: JSON.stringify(body),
    })
      .then(async (res) => {
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} ${txt}`);
        }
        message.success(`updated workers to ${value}`);
      })
      .catch(() => {
        message.error("failed to update workers");
      });
  }

  return (
    <div style={{ minHeight: "100vh", background: "#ffffff", color: "#0b0c0f" }}>
      <TopMenu
        authLabel={userEmail || "login / sign-up"}
        authHref={(() => {
          const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
          if (configured) {
            try {
              const configuredUrl = new URL(configured);
              const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
              const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
              if (isConfiguredLocal && !isPageLocal) {
                // ignore local auth URL on non-localhost pages
              } else {
                // On non-local hosts, prefer explicit index.html so returnTo is added to the file URL
                if (!isConfiguredLocal) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  if (!endsWithHtml) {
                    const base = hasTrailingSlash ? configured.replace(/\/$/, "") : configured;
                    return base + "/index.html";
                  }
                }
                return configured;
              }
            } catch {
              return configured;
            }
          }
          if (window.location.hostname === "localhost") return "http://localhost:5173";
          return "/auth/index.html";
        })()}
        isAuthenticated={Boolean(userEmail)}
        centeredTitle={refAdeme}
        logoutHref={(() => {
          const domain = (import.meta.env.VITE_COGNITO_DOMAIN_URL as string | undefined)?.replace(/^https?:\/\//, "");
          if (!domain) return undefined;
          const clientId = import.meta.env.VITE_COGNITO_CLIENT_ID as string | undefined;
          const logoutRedirect = (import.meta.env.VITE_LOGOUT_REDIRECT_URL as string | undefined) || window.location.origin;
          if (!clientId) return undefined;
          return `https://${domain}/logout?client_id=${encodeURIComponent(clientId)}&logout_uri=${encodeURIComponent(logoutRedirect)}`;
        })()}
      />
      {/* Invisible iframe to pull session from auth origin when on different ports */}
      {!bridgeReady && (
        <iframe
          src={(() => {
            const configured = import.meta.env.VITE_AUTH_URL as string | undefined;
            if (configured) {
              try {
                const configuredUrl = new URL(configured);
                const isConfiguredLocal = ["localhost", "127.0.0.1"].includes(configuredUrl.hostname);
                const isPageLocal = ["localhost", "127.0.0.1"].includes(window.location.hostname);
                if (!(isConfiguredLocal && !isPageLocal)) {
                  const pathname = configuredUrl.pathname || "/";
                  const endsWithHtml = /\.html$/i.test(pathname);
                  const hasTrailingSlash = /\/$/.test(pathname);
                  const base = endsWithHtml ? configured : (hasTrailingSlash ? configured.replace(/\/$/, "") + "/index.html" : configured + "/index.html");
                  return base;
                }
              } catch {
                return configured.replace(/\/$/, "") + "/index.html";
              }
            }
            if (window.location.hostname === "localhost") return "http://localhost:5173/index.html";
            return "/auth/index.html";
          })()}
          style={{ display: "none" }}
          title="session-bridge"
        />
      )}
      <div style={{ padding: 24 }}>
      <div style={{ display: "flex", alignItems: "flex-start", gap: 16 }}>
        {isEditorOpen ? (
          <DpeDrawerEditor
            inline
            open={isEditorOpen}
            onClose={() => setIsEditorOpen(false)}
            width={480}
            rootJsonText={jsonText}
            onApply={(next) => { hasUserEditedRef.current = true; flushSync(() => setJsonText(next)); }}
            apiLoadParams={refAdeme ? { baseUrl: (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr", ref_ademe: refAdeme } : undefined}
            getAccessToken={getAccessToken}
            onLoadedFromApi={(data) => {
              try {
                const text = JSON.stringify(data, null, 2);
                setJsonText((prev) => (prev?.trim() ? prev : text));
              } catch {}
            }}
            onHighlightJsonPath={({ collection, itemKey, indices }) => {
              try {
                const ta = textAreaRef.current;
                if (!ta) return;
                const text = ta.value;
                const variantPath = `dpe.logement.enveloppe.${collection}.${itemKey}`;
                let searchFrom = 0;
                let scopeArrayStart = -1;
                let scopeArrayEnd = -1;
                while (true) {
                  const varIdx = text.indexOf('"elements_variant"', searchFrom);
                  if (varIdx === -1) break;
                  const quoteIdx = text.indexOf('"', varIdx + 18);
                  const quoteEnd = quoteIdx !== -1 ? text.indexOf('"', quoteIdx + 1) : -1;
                  const value = quoteIdx !== -1 && quoteEnd !== -1 ? text.slice(quoteIdx + 1, quoteEnd) : '';
                  if (value === variantPath) {
                    const scopeKeyIdx = text.indexOf('"elements_scope"', varIdx);
                    if (scopeKeyIdx !== -1) {
                      const openBracket = text.indexOf('[', scopeKeyIdx);
                      if (openBracket !== -1) {
                        scopeArrayStart = openBracket;
                        const closeBracket = text.indexOf(']', openBracket);
                        if (closeBracket !== -1) scopeArrayEnd = closeBracket + 1;
                      }
                    }
                    break;
                  }
                  searchFrom = varIdx + 1;
                }
                if (scopeArrayStart === -1 || scopeArrayEnd === -1) return;
                const prevSelStart = ta.selectionStart;
                const prevSelEnd = ta.selectionEnd;
                const prevScrollTop = ta.scrollTop;
                const prevScrollLeft = ta.scrollLeft;
                try { (ta as any).focus({ preventScroll: true }); } catch { try { ta.focus(); } catch {} }
                try { ta.setSelectionRange(scopeArrayStart, scopeArrayEnd); } catch {}
                try { ta.scrollTop = prevScrollTop; ta.scrollLeft = prevScrollLeft; } catch {}
                window.setTimeout(() => {
                  try {
                    (ta as any).focus({ preventScroll: true });
                    ta.setSelectionRange(prevSelStart, prevSelEnd);
                    ta.scrollTop = prevScrollTop;
                    ta.scrollLeft = prevScrollLeft;
                  } catch {}
                }, 600);
              } catch {}
            }}
          />
        ) : null}

        <div style={{ flex: 1 }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12 }}>
            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
              <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Simulation</Title>
              <Button type="primary" size="large" icon={<LeftOutlined />} onClick={openEditor} disabled={isEditorOpen}>Edit</Button>
            </div>
            <Button onClick={() => setIsChainlitOpen(true)}>build with AI</Button>
          </div>
          <Paragraph style={{ color: "#4b5563", marginTop: 4 }}>Provide JSON and configure options, then submit.</Paragraph>
          
          <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
            <div style={{ display: "grid" }}>
              <textarea
                ref={textAreaRef}
                value={jsonText}
                onChange={(e) => { hasUserEditedRef.current = true; setJsonText(e.target.value); }}
                placeholder="Paste or write JSON here"
                style={{
                  minHeight: 420,
                  width: "100%",
                  background: isEditorOpen ? "#f3f4f6" : "#ffffff",
                  color: isEditorOpen ? "#6b7280" : "#111827",
                  border: "1px solid #e5e7eb",
                  borderRadius: 8,
                  padding: 12,
                  fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace",
                  fontSize: 14,
                  lineHeight: 1.45,
                  resize: "vertical",
                  cursor: isEditorOpen ? "default" : "text",
                  overflow: "auto",
                }}
                readOnly={isEditorOpen}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <Collapse
                destroyOnHidden
                items={[
                  {
                    key: "options",
                    label: "Options",
                    children: (
                      <Space direction="vertical" size={12} style={{ width: "100%" }}>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>api_debug</div>
                          <Select
                            value={apiDebug as number | undefined}
                            onChange={(v) => setApiDebug(v)}
                            allowClear
                            placeholder="none"
                            options={apiDebugOptions}
                            style={{ width: "100%" }}
                          />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>skip</div>
                          <InputNumber value={skip} onChange={(v) => setSkip(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>limit</div>
                          <InputNumber value={limit} onChange={(v) => setLimit(Number(v ?? 0))} style={{ width: "100%" }} min={0} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb chunks</div>
                          <InputNumber value={numChunks} onChange={(v) => setNumChunks(Number(v ?? 1))} style={{ width: "100%" }} min={1} />
                        </div>
                        <div>
                          <div style={{ marginBottom: 6, color: "#4b5563" }}>nb workers</div>
                          <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                            <InputNumber value={numWorkers} onChange={(v) => { setWorkersError(undefined); setNumWorkers(Number(v ?? 1)); }} style={{ width: 140 }} min={1} />
                            <Button size="small" onClick={handleConfirmWorkers}>ok</Button>
                            {typeof confirmedWorkers === "number" && (
                              <span style={{ color: "#059669", fontSize: 12 }}>saved: {confirmedWorkers}</span>
                            )}
                          </div>
                          {workersError && (
                            <div style={{ marginTop: 4, color: "#ef4444", fontSize: 12 }}>{workersError}</div>
                          )}
                        </div>
                      </Space>
                    ),
                  },
                ]}
              />
            </div>
            <div style={{ marginTop: 12 }}>
              <div style={{ display: "flex", gap: 8, justifyContent: "flex-end", alignItems: "center" }}>
                <Tooltip title={isSubmitBlocked ? "confirm simulation with OK (left panel), first." : undefined}>
                  <span style={{ display: "inline-block" }}>
                    <Button type="primary" onClick={handleSubmit} loading={submitting} disabled={isSubmitBlocked}>submit</Button>
                  </span>
                </Tooltip>
                <div style={{ position: "relative" }}>
                  <Button onClick={() => setIsSaveMenuOpen((v) => !v)}>...</Button>
                  {isSaveMenuOpen && (
                    <div style={{ position: "absolute", right: 0, top: "100%", background: "#fff", border: "1px solid #e5e7eb", borderRadius: 8, padding: 8, width: 260, boxShadow: "0 4px 14px rgba(0,0,0,0.08)", zIndex: 10 }}>
                    <div style={{ padding: "6px 8px", cursor: "pointer", borderRadius: 6 }} onClick={() => { setIsLoadSavedOpen(true); setIsSaveMenuOpen(false); }}>load scenario</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={() => { if (!isSaving) handleSaveToBackoffice(); }}>save {simulLog || "default"}</div>
                    <div style={{ height: 1, background: "#e5e7eb", margin: "6px 0" }} />
                    <div style={{ padding: "6px 8px", cursor: isSaving ? "default" : "pointer", opacity: isSaving ? 0.6 : 1, borderRadius: 6 }} onClick={async () => {
                      if (isSaving) return;
                      const cdEnv = ((import.meta as any)?.env?.VITE_CD_ENV as string | undefined) || (import.meta.env.MODE === "development" ? "dev" : "prod");
                      const suggested = `${cdEnv}_simul_${simulLog || "test0001"}`;
                      const name = window.prompt(
                        "Save as name (format: <CD_ENV>_simul_<name>, e.g., dev_simul_test0001):",
                        suggested
                      );
                      if (!name) { setIsSaveMenuOpen(false); return; }
                      try {
                        const ref = `${refAdeme || "unknown"}-${name}`;
                        const base = (import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr";
                        const apiUrl = new URL("/backoffice/redis_file_manage", base);
                        setIsSaving(true);
                        // eslint-disable-next-line no-console
                        console.debug("[simulation] POST redis_file_manage (save as)", { url: apiUrl.toString(), ref });
                        const res = await authorizedFetch(apiUrl.toString(), {
                          method: "POST",
                          headers: {
                            "Content-Type": "application/json",
                            Accept: "application/json, text/plain, */*",
                            "x-authorization": "dperdition",
                          },
                          body: JSON.stringify({ ref, text: jsonText }),
                        });
                        if (!res.ok) {
                          const txt = await res.text().catch(() => "");
                          throw new Error(`HTTP ${res.status} ${txt}`);
                        }
                        message.success(`saved ${name}`);
                        if (refAdeme) {
                          const { origin, pathname } = window.location;
                          const basePath = (() => {
                            try {
                              const idx = pathname.lastIndexOf("/");
                              return idx !== -1 ? pathname.slice(0, idx + 1) : "/";
                            } catch {
                              return "/";
                            }
                          })();
                          const targetUrl = `${origin}${basePath}index.html?ref_ademe=${encodeURIComponent(refAdeme)}&simul=${encodeURIComponent(name)}`;
                          window.location.href = targetUrl;
                        }
                      } catch {
                        message.error("save failed");
                      } finally {
                        setIsSaving(false);
                        setIsSaveMenuOpen(false);
                      }
                    }}>save as…</div>
                    </div>
                  )}
                </div>
              </div>
              <div style={{ marginTop: 8, display: "flex", justifyContent: "flex-start", minHeight: 24 }}>
                {!resultsUrl && isPolling && (
                  <Spin size="small" />
                )}
                {resultsUrl && (
                  <a href={resultsUrl} target="_blank" rel="noopener noreferrer" style={{ display: "inline-flex", alignItems: "center", gap: 6 }}>
                    Open simulation results <ExportOutlined />
                  </a>
                )}
              </div>
              {refAdeme ? (
                <div style={{ marginTop: 20 }}>
                  <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12, marginBottom: 12 }}>
                    <Title level={2} style={{ color: "#0b0c0f", margin: 0 }}>Results preview</Title>
                  </div>
                  <Card style={{ background: "#ffffff", borderColor: "#e5e7eb" }} styles={{ body: { padding: 16 } }}>
                    <SimulationResults
                      dpeId={refAdeme}
                      getAccessToken={async () => (await getAccessToken()) || undefined}
                      apiBaseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
                      width={720}
                      height={300}
                    />
                  </Card>
                </div>
              ) : null}
              {queueSegments > 0 && (
                <div style={{ marginTop: 12 }}>
                  <div style={{ height: 10, background: "#e5e7eb", borderRadius: 8, overflow: "hidden", display: "flex" }}>
                    {(queueItems.length ? queueItems : Array.from({ length: queueSegments })).map((item: any, idx: number) => {
                      const ts = item?.ts_started;
                      let startedAtMs = 0;
                      try {
                        if (typeof ts === "number") startedAtMs = ts > 1e12 ? ts : ts * 1000;
                        else if (typeof ts === "string") {
                          const n = Number(ts);
                          if (Number.isFinite(n)) startedAtMs = n > 1e12 ? n : n * 1000; else {
                            const t = Date.parse(ts);
                            if (!Number.isNaN(t)) startedAtMs = t;
                          }
                        }
                      } catch {}
                      const elapsedSec = Math.max(0, (Date.now() - startedAtMs) / 1000);
                      const statusNum = Number(item?.status ?? 0);
                      const pct = statusNum === 1 ? 100 : Math.max(0, Math.min(100, (elapsedSec / 60) * 100));
                      const fillColor = statusNum === 1 ? "#93c5fd" : "transparent";
                      return (
                        <div key={idx} style={{ flex: 1, display: "flex" }}>
                          <div style={{ width: `${pct}%`, background: fillColor, transition: "width 1s linear" }} />
                          {idx < queueSegments - 1 ? (
                            <div style={{ width: 2, background: "#ffffff" }} />
                          ) : null}
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              {/* editor inline panel is rendered on the right */}
            </div>
            <SimulationScenariosModal
              open={isScenariosOpen}
              onCancel={() => setIsScenariosOpen(false)}
              onLoad={(runs) => {
                try {
                  setJsonText(JSON.stringify(runs, null, 2));
                } catch {
                  // fallback to empty array
                  setJsonText(JSON.stringify([], null, 2));
                }
                setIsScenariosOpen(false);
              }}
            />
            <LoadScenarioModal
              open={isLoadSavedOpen}
              onCancel={() => setIsLoadSavedOpen(false)}
              onSelect={(payload: unknown) => {
                try {
                  // Accept payload either as normalized object { ref_ademe, label } or string "ref:label"
                  let ref: string | undefined;
                  let simul: string | undefined;
                  if (typeof payload === "string") {
                    const colon = payload.indexOf(":");
                    ref = colon !== -1 ? payload.slice(0, colon) : undefined;
                    simul = colon !== -1 ? payload.slice(colon + 1) : undefined;
                  } else if (payload && typeof payload === "object") {
                    ref = (payload as any).ref_ademe as string | undefined;
                    simul = (payload as any).label as string | undefined;
                  }
                  const url = new URL(window.location.href);
                  if (ref) url.searchParams.set("ref_ademe", ref);
                  if (simul) url.searchParams.set("simul", simul);
                  window.location.href = url.toString();
                } catch {}
                setIsLoadSavedOpen(false);
              }}
              baseUrl={(import.meta.env.VITE_BACKOFFICE_API_URL as string) || "https://api-dev.etiquettedpe.fr"}
              initialRefAdeme={refAdeme}
              getAccessToken={getAccessToken}
            />
          </Card>
        </div>

        {(() => {
          const chainlitUrl = (() => {
            const configured = import.meta.env.VITE_CHAINLIT_URL as string | undefined;
            if (configured && typeof configured === "string" && configured.trim()) return configured.trim();
            return "https://chainlit-stg.etiquettedpe.fr/chainlit";
          })();
          return (
            <ChainlitChatDrawer
              open={isChainlitOpen}
              onClose={() => setIsChainlitOpen(false)}
              title="Assistant"
              serverUrl={chainlitUrl}
              userEnv={{
                mail: "germain.blanchet@gmail.com",
                button_id: "contactez_nous",
                ref_ademe: refAdeme || "2508E0243162W",
              }}
            />
          );
        })()}

      </div>
      </div>
    </div>
  );
};



```

Stopped the post-submit report polling:

- Removed the `startPollingForResults` call in `handleSubmit` and cancel any active poll instead, ensuring no more `get_redis_detail` requests after submit.
- Kept the queue polling logic for segmented progress untouched.

Impact:
- The loader under submit will no longer reflect remote report status; it will only show the local submit state and any queue progress if enabled.

